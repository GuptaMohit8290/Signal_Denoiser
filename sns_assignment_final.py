# -*- coding: utf-8 -*-
"""sns_assignment_final

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UD_4SWS7SlzgGAoH8YD3Y5evgTWSNETt
"""

#by:


!pip install pydub
!apt install ffmpeg
!pip install librosa

import wave

filename = 's1_mohit500.wav' # replace with your WAV file name
wavefile = wave.open(filename, 'rb')
nframes = wavefile.getnframes()
print(f'Total number of frames: {nframes}')
wavefile.close()

#new new new i guess the correct one!
import numpy as np
from scipy.io import wavfile
import matplotlib.pyplot as plt
import scipy.signal as sps


import librosa

from pydub import AudioSegment
def DFT(x):
    """
    Function to calculate the 
    discrete Fourier Transform 
    of a 1D real-valued signal x
    """

    N = len(x)
    n = np.arange(N)
    k = n.reshape((N, 1))
    e = np.exp(-2j * np.pi * k * n / N)
    
    X = np.dot(e, x)
    
    return X

_, signal = wavfile.read('s1_mohi500.wav')
# Define the sampling frequencies to analyze
fs = [500]


# Calculate DFT and plot magnitude spectrum for each sampling frequency
for i in fs:
    # Resample the signal
    new_rate = i
    number_of_samples = round(len(signal) * float(new_rate) / _)
    resampled_signal = sps.resample(signal, number_of_samples)

    # Number of samples in the resampled signal
    N = resampled_signal.shape[0]

    # Time vector
    t = np.arange(N) / new_rate

    # Frequency vector
    freq_range = np.linspace(0, new_rate/2, N//2)
  
    # Calculate DFT
    dft_signal = DFT(resampled_signal)
    # Plot magnitude spectrum
    plt.figure()
    plt.plot(freq_range, np.abs(dft_signal[:N//2]))
    plt.xlabel('Frequency (Hz)')
    plt.ylabel('Magnitude')
    plt.title('Magnitude Spectrum (fs = {} Hz)'.format(new_rate))
    plt.show()

#filtering of the signals!
# Load the recorded signal from a file
recorded_signal, fs = librosa.load('s1_mohi500.wav', sr=None)

# Define the filter coefficients
filter_order = 100
filter_cutoff = 240 # Hz
filter_coeffs = sps.firwin(filter_order, filter_cutoff, fs=fs)

# Apply the filter to the recorded signal
filtered_signal = sps.convolve(recorded_signal, filter_coeffs, mode='same')

# Plot the recorded and filtered signals
time = np.arange(len(recorded_signal)) / fs

fig, ax = plt.subplots(2, 1, sharex=True, figsize=(8, 6))
ax[0].plot(time, recorded_signal)
ax[0].set_ylabel('Amplitude')
ax[0].set_title('Recorded signal')
ax[1].plot(time, filtered_signal)
ax[1].set_xlabel('Time (s)')
ax[1].set_ylabel('Amplitude')
ax[1].set_title('Filtered signal')
plt.show()

#new new new i guess the correct one!
import numpy as np
from scipy.io import wavfile
import matplotlib.pyplot as plt
import scipy.signal as sps


import librosa

from pydub import AudioSegment
def DFT(x):
    """
    Function to calculate the 
    discrete Fourier Transform 
    of a 1D real-valued signal x
    """

    N = len(x)
    n = np.arange(N)
    k = n.reshape((N, 1))
    e = np.exp(-2j * np.pi * k * n / N)
    
    X = np.dot(e, x)
    
    return X

_, signal = wavfile.read('s2_mohi500.wav')
# Define the sampling frequencies to analyze
fs = [500]


# Calculate DFT and plot magnitude spectrum for each sampling frequency
for i in fs:
    # Resample the signal
    new_rate = i
    number_of_samples = round(len(signal) * float(new_rate) / _)
    resampled_signal = sps.resample(signal, number_of_samples)

    # Number of samples in the resampled signal
    N = resampled_signal.shape[0]

    # Time vector
    t = np.arange(N) / new_rate

    # Frequency vector
    freq_range = np.linspace(0, new_rate/2, N//2)
  
    # Calculate DFT
    dft_signal = DFT(resampled_signal)
    # Plot magnitude spectrum
    plt.figure()
    plt.plot(freq_range, np.abs(dft_signal[:N//2]))
    plt.xlabel('Frequency (Hz)')
    plt.ylabel('Magnitude')
    plt.title('Magnitude Spectrum (fs = {} Hz)'.format(new_rate))
    plt.show()

#filtering of the signals!
# Load the recorded signal from a file
recorded_signal, fs = librosa.load('s2_mohi500.wav', sr=None)

# Define the filter coefficients
filter_order = 100
filter_cutoff = 240 # Hz
filter_coeffs = sps.firwin(filter_order, filter_cutoff, fs=fs)

# Apply the filter to the recorded signal
filtered_signal = sps.convolve(recorded_signal, filter_coeffs, mode='same')

# Plot the recorded and filtered signals
time = np.arange(len(recorded_signal)) / fs

fig, ax = plt.subplots(2, 1, sharex=True, figsize=(8, 6))
ax[0].plot(time, recorded_signal)
ax[0].set_ylabel('Amplitude')
ax[0].set_title('Recorded signal')
ax[1].plot(time, filtered_signal)
ax[1].set_xlabel('Time (s)')
ax[1].set_ylabel('Amplitude')
ax[1].set_title('Filtered signal')
plt.show()

#new new new i guess the correct one!
import numpy as np
from scipy.io import wavfile
import matplotlib.pyplot as plt
import scipy.signal as sps


import librosa

from pydub import AudioSegment
def DFT(x):
    """
    Function to calculate the 
    discrete Fourier Transform 
    of a 1D real-valued signal x
    """

    N = len(x)
    n = np.arange(N)
    k = n.reshape((N, 1))
    e = np.exp(-2j * np.pi * k * n / N)
    
    X = np.dot(e, x)
    
    return X

_, signal = wavfile.read('s3_mohi500.wav')
# Define the sampling frequencies to analyze
fs = [500]


# Calculate DFT and plot magnitude spectrum for each sampling frequency
for i in fs:
    # Resample the signal
    new_rate = i
    number_of_samples = round(len(signal) * float(new_rate) / _)
    resampled_signal = sps.resample(signal, number_of_samples)

    # Number of samples in the resampled signal
    N = resampled_signal.shape[0]

    # Time vector
    t = np.arange(N) / new_rate

    # Frequency vector
    freq_range = np.linspace(0, new_rate/2, N//2)
  
    # Calculate DFT
    dft_signal = DFT(resampled_signal)
    # Plot magnitude spectrum
    plt.figure()
    plt.plot(freq_range, np.abs(dft_signal[:N//2]))
    plt.xlabel('Frequency (Hz)')
    plt.ylabel('Magnitude')
    plt.title('Magnitude Spectrum (fs = {} Hz)'.format(new_rate))
    plt.show()

#filtering of the signals!
# Load the recorded signal from a file
recorded_signal, fs = librosa.load('s3_mohi500.wav', sr=None)

# Define the filter coefficients
filter_order = 100
filter_cutoff = 240 # Hz
filter_coeffs = sps.firwin(filter_order, filter_cutoff, fs=fs)

# Apply the filter to the recorded signal
filtered_signal = sps.convolve(recorded_signal, filter_coeffs, mode='same')

# Plot the recorded and filtered signals
time = np.arange(len(recorded_signal)) / fs

fig, ax = plt.subplots(2, 1, sharex=True, figsize=(8, 6))
ax[0].plot(time, recorded_signal)
ax[0].set_ylabel('Amplitude')
ax[0].set_title('Recorded signal')
ax[1].plot(time, filtered_signal)
ax[1].set_xlabel('Time (s)')
ax[1].set_ylabel('Amplitude')
ax[1].set_title('Filtered signal')
plt.show()

#new new new i guess the correct one!
import numpy as np
from scipy.io import wavfile
import matplotlib.pyplot as plt
import scipy.signal as sps


import librosa

from pydub import AudioSegment
def DFT(x):
    """
    Function to calculate the 
    discrete Fourier Transform 
    of a 1D real-valued signal x
    """

    N = len(x)
    n = np.arange(N)
    k = n.reshape((N, 1))
    e = np.exp(-2j * np.pi * k * n / N)
    
    X = np.dot(e, x)
    
    return X

_, signal = wavfile.read('s4_mohi500.wav')
# Define the sampling frequencies to analyze
fs = [500]


# Calculate DFT and plot magnitude spectrum for each sampling frequency
for i in fs:
    # Resample the signal
    new_rate = i
    number_of_samples = round(len(signal) * float(new_rate) / _)
    resampled_signal = sps.resample(signal, number_of_samples)

    # Number of samples in the resampled signal
    N = resampled_signal.shape[0]

    # Time vector
    t = np.arange(N) / new_rate

    # Frequency vector
    freq_range = np.linspace(0, new_rate/2, N//2)
  
    # Calculate DFT
    dft_signal = DFT(resampled_signal)
    # Plot magnitude spectrum
    plt.figure()
    plt.plot(freq_range, np.abs(dft_signal[:N//2]))
    plt.xlabel('Frequency (Hz)')
    plt.ylabel('Magnitude')
    plt.title('Magnitude Spectrum (fs = {} Hz)'.format(new_rate))
    plt.show()

#filtering of the signals!
# Load the recorded signal from a file
recorded_signal, fs = librosa.load('s4_mohi500.wav', sr=None)

# Define the filter coefficients
filter_order = 100
filter_cutoff = 240 # Hz
filter_coeffs = sps.firwin(filter_order, filter_cutoff, fs=fs)

# Apply the filter to the recorded signal
filtered_signal = sps.convolve(recorded_signal, filter_coeffs, mode='same')

# Plot the recorded and filtered signals
time = np.arange(len(recorded_signal)) / fs

fig, ax = plt.subplots(2, 1, sharex=True, figsize=(8, 6))
ax[0].plot(time, recorded_signal)
ax[0].set_ylabel('Amplitude')
ax[0].set_title('Recorded signal')
ax[1].plot(time, filtered_signal)
ax[1].set_xlabel('Time (s)')
ax[1].set_ylabel('Amplitude')
ax[1].set_title('Filtered signal')
plt.show()

#new new new i guess the correct one!
import numpy as np
from scipy.io import wavfile
import matplotlib.pyplot as plt
import scipy.signal as sps


import librosa

from pydub import AudioSegment
def DFT(x):
    """
    Function to calculate the 
    discrete Fourier Transform 
    of a 1D real-valued signal x
    """

    N = len(x)
    n = np.arange(N)
    k = n.reshape((N, 1))
    e = np.exp(-2j * np.pi * k * n / N)
    
    X = np.dot(e, x)
    
    return X

_, signal = wavfile.read('s1_mohi2000.wav')
# Define the sampling frequencies to analyze
fs = [2000]


# Calculate DFT and plot magnitude spectrum for each sampling frequency
for i in fs:
    # Resample the signal
    new_rate = i
    number_of_samples = round(len(signal) * float(new_rate) / _)
    resampled_signal = sps.resample(signal, number_of_samples)

    # Number of samples in the resampled signal
    N = resampled_signal.shape[0]

    # Time vector
    t = np.arange(N) / new_rate

    # Frequency vector
    freq_range = np.linspace(0, new_rate/2, N//2)
  
    # Calculate DFT
    dft_signal = DFT(resampled_signal)
    # Plot magnitude spectrum
    plt.figure()
    plt.plot(freq_range, np.abs(dft_signal[:N//2]))
    plt.xlabel('Frequency (Hz)')
    plt.ylabel('Magnitude')
    plt.title('Magnitude Spectrum (fs = {} Hz)'.format(new_rate))
    plt.show()

#filtering of the signals!
# Load the recorded signal from a file
recorded_signal, fs = librosa.load('s1_mohi2000.wav', sr=None)

# Define the filter coefficients
filter_order = 500
filter_cutoff = 700 # Hz
filter_coeffs = sps.firwin(filter_order, filter_cutoff, fs=fs)

# Apply the filter to the recorded signal
filtered_signal = sps.convolve(recorded_signal, filter_coeffs, mode='same')

# Plot the recorded and filtered signals
time = np.arange(len(recorded_signal)) / fs

fig, ax = plt.subplots(2, 1, sharex=True, figsize=(8, 6))
ax[0].plot(time, recorded_signal)
ax[0].set_ylabel('Amplitude')
ax[0].set_title('Recorded signal')
ax[1].plot(time, filtered_signal)
ax[1].set_xlabel('Time (s)')
ax[1].set_ylabel('Amplitude')
ax[1].set_title('Filtered signal')
plt.show()

#new new new i guess the correct one!
import numpy as np
from scipy.io import wavfile
import matplotlib.pyplot as plt
import scipy.signal as sps


import librosa

from pydub import AudioSegment
def DFT(x):
    """
    Function to calculate the 
    discrete Fourier Transform 
    of a 1D real-valued signal x
    """

    N = len(x)
    n = np.arange(N)
    k = n.reshape((N, 1))
    e = np.exp(-2j * np.pi * k * n / N)
    
    X = np.dot(e, x)
    
    return X

_, signal = wavfile.read('s2_mohi2000.wav')
# Define the sampling frequencies to analyze
fs = [2000]


# Calculate DFT and plot magnitude spectrum for each sampling frequency
for i in fs:
    # Resample the signal
    new_rate = i
    number_of_samples = round(len(signal) * float(new_rate) / _)
    resampled_signal = sps.resample(signal, number_of_samples)

    # Number of samples in the resampled signal
    N = resampled_signal.shape[0]

    # Time vector
    t = np.arange(N) / new_rate

    # Frequency vector
    freq_range = np.linspace(0, new_rate/2, N//2)
  
    # Calculate DFT
    dft_signal = DFT(resampled_signal)
    # Plot magnitude spectrum
    plt.figure()
    plt.plot(freq_range, np.abs(dft_signal[:N//2]))
    plt.xlabel('Frequency (Hz)')
    plt.ylabel('Magnitude')
    plt.title('Magnitude Spectrum (fs = {} Hz)'.format(new_rate))
    plt.show()

#filtering of the signals!
# Load the recorded signal from a file
recorded_signal, fs = librosa.load('s2_mohi2000.wav', sr=None)

# Define the filter coefficients
filter_order = 500
filter_cutoff = 500 # Hz
filter_coeffs = sps.firwin(filter_order, filter_cutoff, fs=fs)

# Apply the filter to the recorded signal
filtered_signal = sps.convolve(recorded_signal, filter_coeffs, mode='same')

# Plot the recorded and filtered signals
time = np.arange(len(recorded_signal)) / fs

fig, ax = plt.subplots(2, 1, sharex=True, figsize=(8, 6))
ax[0].plot(time, recorded_signal)
ax[0].set_ylabel('Amplitude')
ax[0].set_title('Recorded signal')
ax[1].plot(time, filtered_signal)
ax[1].set_xlabel('Time (s)')
ax[1].set_ylabel('Amplitude')
ax[1].set_title('Filtered signal')
plt.show()

#new new new i guess the correct one!
import numpy as np
from scipy.io import wavfile
import matplotlib.pyplot as plt
import scipy.signal as sps


import librosa

from pydub import AudioSegment
def DFT(x):
    """
    Function to calculate the 
    discrete Fourier Transform 
    of a 1D real-valued signal x
    """

    N = len(x)
    n = np.arange(N)
    k = n.reshape((N, 1))
    e = np.exp(-2j * np.pi * k * n / N)
    
    X = np.dot(e, x)
    
    return X

_, signal = wavfile.read('s3_mohi2000.wav')
# Define the sampling frequencies to analyze
fs = [2000]


# Calculate DFT and plot magnitude spectrum for each sampling frequency
for i in fs:
    # Resample the signal
    new_rate = i
    number_of_samples = round(len(signal) * float(new_rate) / _)
    resampled_signal = sps.resample(signal, number_of_samples)

    # Number of samples in the resampled signal
    N = resampled_signal.shape[0]

    # Time vector
    t = np.arange(N) / new_rate

    # Frequency vector
    freq_range = np.linspace(0, new_rate/2, N//2)
  
    # Calculate DFT
    dft_signal = DFT(resampled_signal)
    # Plot magnitude spectrum
    plt.figure()
    plt.plot(freq_range, np.abs(dft_signal[:N//2]))
    plt.xlabel('Frequency (Hz)')
    plt.ylabel('Magnitude')
    plt.title('Magnitude Spectrum (fs = {} Hz)'.format(new_rate))
    plt.show()

#filtering of the signals!
# Load the recorded signal from a file
recorded_signal, fs = librosa.load('s3_mohi2000.wav', sr=None)

# Define the filter coefficients
filter_order = 500
filter_cutoff = 700 # Hz
filter_coeffs = sps.firwin(filter_order, filter_cutoff, fs=fs)

# Apply the filter to the recorded signal
filtered_signal = sps.convolve(recorded_signal, filter_coeffs, mode='same')

# Plot the recorded and filtered signals
time = np.arange(len(recorded_signal)) / fs

fig, ax = plt.subplots(2, 1, sharex=True, figsize=(8, 6))
ax[0].plot(time, recorded_signal)
ax[0].set_ylabel('Amplitude')
ax[0].set_title('Recorded signal')
ax[1].plot(time, filtered_signal)
ax[1].set_xlabel('Time (s)')
ax[1].set_ylabel('Amplitude')
ax[1].set_title('Filtered signal')
plt.show()

#new new new i guess the correct one!
import numpy as np
from scipy.io import wavfile
import matplotlib.pyplot as plt
import scipy.signal as sps


import librosa

from pydub import AudioSegment
def DFT(x):
    """
    Function to calculate the 
    discrete Fourier Transform 
    of a 1D real-valued signal x
    """

    N = len(x)
    n = np.arange(N)
    k = n.reshape((N, 1))
    e = np.exp(-2j * np.pi * k * n / N)
    
    X = np.dot(e, x)
    
    return X

_, signal = wavfile.read('s4_mohi2000.wav')
# Define the sampling frequencies to analyze
fs = [2000]


# Calculate DFT and plot magnitude spectrum for each sampling frequency
for i in fs:
    # Resample the signal
    new_rate = i
    number_of_samples = round(len(signal) * float(new_rate) / _)
    resampled_signal = sps.resample(signal, number_of_samples)

    # Number of samples in the resampled signal
    N = resampled_signal.shape[0]

    # Time vector
    t = np.arange(N) / new_rate

    # Frequency vector
    freq_range = np.linspace(0, new_rate/2, N//2)
  
    # Calculate DFT
    dft_signal = DFT(resampled_signal)
    # Plot magnitude spectrum
    plt.figure()
    plt.plot(freq_range, np.abs(dft_signal[:N//2]))
    plt.xlabel('Frequency (Hz)')
    plt.ylabel('Magnitude')
    plt.title('Magnitude Spectrum (fs = {} Hz)'.format(new_rate))
    plt.show()

#filtering of the signals!
# Load the recorded signal from a file
recorded_signal, fs = librosa.load('s4_mohi2000.wav', sr=None)

# Define the filter coefficients
filter_order = 500
filter_cutoff = 700 # Hz
filter_coeffs = sps.firwin(filter_order, filter_cutoff, fs=fs)

# Apply the filter to the recorded signal
filtered_signal = sps.convolve(recorded_signal, filter_coeffs, mode='same')

# Plot the recorded and filtered signals
time = np.arange(len(recorded_signal)) / fs

fig, ax = plt.subplots(2, 1, sharex=True, figsize=(8, 6))
ax[0].plot(time, recorded_signal)
ax[0].set_ylabel('Amplitude')
ax[0].set_title('Recorded signal')
ax[1].plot(time, filtered_signal)
ax[1].set_xlabel('Time (s)')
ax[1].set_ylabel('Amplitude')
ax[1].set_title('Filtered signal')
plt.show()

#new new new i guess the correct one!
import numpy as np
from scipy.io import wavfile
import matplotlib.pyplot as plt
import scipy.signal as sps


import librosa

from pydub import AudioSegment
def DFT(x):
    """
    Function to calculate the 
    discrete Fourier Transform 
    of a 1D real-valued signal x
    """

    N = len(x)
    n = np.arange(N)
    k = n.reshape((N, 1))
    e = np.exp(-2j * np.pi * k * n / N)
    
    X = np.dot(e, x)
    
    return X

_, signal = wavfile.read('s1_mohi16000.wav')
# Define the sampling frequencies to analyze
fs = [16000]


# Calculate DFT and plot magnitude spectrum for each sampling frequency
for i in fs:
    # Resample the signal
    new_rate = i
    number_of_samples = round(len(signal) * float(new_rate) / _)
    resampled_signal = sps.resample(signal, number_of_samples)

    # Number of samples in the resampled signal
    N = resampled_signal.shape[0]

    # Time vector
    from numpy.fft import fft as dFT
    t = np.arange(N) / new_rate

    # Frequency vector
    freq_range = np.linspace(0, new_rate/2, N//2)
  
    # Calculate DFT
    dft_signal = dFT(resampled_signal)
    # Plot magnitude spectrum
    plt.figure()
    plt.plot(freq_range, np.abs(dft_signal[:N//2]))
    plt.xlabel('Frequency (Hz)')
    plt.ylabel('Magnitude')
    plt.title('Magnitude Spectrum (fs = {} Hz)'.format(new_rate))
    plt.show()

#filtering of the signals!
# Load the recorded signal from a file
recorded_signal, fs = librosa.load('s1_mohi16000.wav', sr=None)

# Define the filter coefficients
filter_order = 1000
filter_cutoff = 4000 # Hz
filter_coeffs = sps.firwin(filter_order, filter_cutoff, fs=fs)

# Apply the filter to the recorded signal
filtered_signal = sps.convolve(recorded_signal, filter_coeffs, mode='same')

# Plot the recorded and filtered signals
time = np.arange(len(recorded_signal)) / fs

fig, ax = plt.subplots(2, 1, sharex=True, figsize=(8, 6))
ax[0].plot(time, recorded_signal)
ax[0].set_ylabel('Amplitude')
ax[0].set_title('Recorded signal')
ax[1].plot(time, filtered_signal)
ax[1].set_xlabel('Time (s)')
ax[1].set_ylabel('Amplitude')
ax[1].set_title('Filtered signal')
plt.show()

#new new new i guess the correct one!
import numpy as np
from scipy.io import wavfile
import matplotlib.pyplot as plt
import scipy.signal as sps


import librosa

from pydub import AudioSegment
def DFT(x):
    """
    Function to calculate the 
    discrete Fourier Transform 
    of a 1D real-valued signal x
    """

    N = len(x)
    n = np.arange(N)
    k = n.reshape((N, 1))
    e = np.exp(-2j * np.pi * k * n / N)
    
    X = np.dot(e, x)
    
    return X

_, signal = wavfile.read('s2_mohi16000.wav')
# Define the sampling frequencies to analyze
fs = [16000]


# Calculate DFT and plot magnitude spectrum for each sampling frequency
for i in fs:
    # Resample the signal
    new_rate = i
    number_of_samples = round(len(signal) * float(new_rate) / _)
    resampled_signal = sps.resample(signal, number_of_samples)

    # Number of samples in the resampled signal
    N = resampled_signal.shape[0]

    # Time vector
    t = np.arange(N) / new_rate
    from numpy.fft import fft as dFT

    # Frequency vector
    freq_range = np.linspace(0, new_rate/2, N//2)
  
    # Calculate DFT
    dft_signal = dFT(resampled_signal)
    # Plot magnitude spectrum
    plt.figure()
    plt.plot(freq_range, np.abs(dft_signal[:N//2]))
    plt.xlabel('Frequency (Hz)')
    plt.ylabel('Magnitude')
    plt.title('Magnitude Spectrum (fs = {} Hz)'.format(new_rate))
    plt.show()

#filtering of the signals!
# Load the recorded signal from a file
recorded_signal, fs = librosa.load('s2_mohi16000.wav', sr=None)

# Define the filter coefficients
filter_order = 1000
filter_cutoff = 3000 # Hz
filter_coeffs = sps.firwin(filter_order, filter_cutoff, fs=fs)

# Apply the filter to the recorded signal
filtered_signal = sps.convolve(recorded_signal, filter_coeffs, mode='same')

# Plot the recorded and filtered signals
time = np.arange(len(recorded_signal)) / fs

fig, ax = plt.subplots(2, 1, sharex=True, figsize=(8, 6))
ax[0].plot(time, recorded_signal)
ax[0].set_ylabel('Amplitude')
ax[0].set_title('Recorded signal')
ax[1].plot(time, filtered_signal)
ax[1].set_xlabel('Time (s)')
ax[1].set_ylabel('Amplitude')
ax[1].set_title('Filtered signal')
plt.show()

#new new new i guess the correct one!
import numpy as np
from scipy.io import wavfile
import matplotlib.pyplot as plt
import scipy.signal as sps


import librosa

from pydub import AudioSegment
def DFT(x):
    """
    Function to calculate the 
    discrete Fourier Transform 
    of a 1D real-valued signal x
    """

    N = len(x)
    n = np.arange(N)
    k = n.reshape((N, 1))
    e = np.exp(-2j * np.pi * k * n / N)
    
    X = np.dot(e, x)
    
    return X

_, signal = wavfile.read('s3_mohi16000.wav')
# Define the sampling frequencies to analyze
fs = [16000]


# Calculate DFT and plot magnitude spectrum for each sampling frequency
for i in fs:
    # Resample the signal
    new_rate = i
    number_of_samples = round(len(signal) * float(new_rate) / _)
    resampled_signal = sps.resample(signal, number_of_samples)

    # Number of samples in the resampled signal
    from numpy.fft import fft as dFT
    N = resampled_signal.shape[0]

    # Time vector
    t = np.arange(N) / new_rate

    # Frequency vector
    freq_range = np.linspace(0, new_rate/2, N//2)
  
    # Calculate DFT
    dft_signal = dFT(resampled_signal)
    # Plot magnitude spectrum
    plt.figure()
    plt.plot(freq_range, np.abs(dft_signal[:N//2]))
    plt.xlabel('Frequency (Hz)')
    plt.ylabel('Magnitude')
    plt.title('Magnitude Spectrum (fs = {} Hz)'.format(new_rate))
    plt.show()

#filtering of the signals!
# Load the recorded signal from a file
recorded_signal, fs = librosa.load('s3_mohi16000.wav', sr=None)

# Define the filter coefficients
filter_order = 1000
filter_cutoff = 2000 # Hz
filter_coeffs = sps.firwin(filter_order, filter_cutoff, fs=fs)

# Apply the filter to the recorded signal
filtered_signal = sps.convolve(recorded_signal, filter_coeffs, mode='same')

# Plot the recorded and filtered signals
time = np.arange(len(recorded_signal)) / fs

fig, ax = plt.subplots(2, 1, sharex=True, figsize=(8, 6))
ax[0].plot(time, recorded_signal)
ax[0].set_ylabel('Amplitude')
ax[0].set_title('Recorded signal')
ax[1].plot(time, filtered_signal)
ax[1].set_xlabel('Time (s)')
ax[1].set_ylabel('Amplitude')
ax[1].set_title('Filtered signal')
plt.show()

#new new new i guess the correct one!
import numpy as np
from scipy.io import wavfile
import matplotlib.pyplot as plt
import scipy.signal as sps


import librosa

from pydub import AudioSegment
def DFT(x):
    """
    Function to calculate the 
    discrete Fourier Transform 
    of a 1D real-valued signal x
    """

    N = len(x)
    n = np.arange(N)
    k = n.reshape((N, 1))
    e = np.exp(-2j * np.pi * k * n / N)
    
    X = np.dot(e, x)
    
    return X

_, signal = wavfile.read('s4_mohi16000.wav')
# Define the sampling frequencies to analyze
fs = [16000]


# Calculate DFT and plot magnitude spectrum for each sampling frequency
for i in fs:
    # Resample the signal
    new_rate = i
    number_of_samples = round(len(signal) * float(new_rate) / _)
    from numpy.fft import fft as dFT
    resampled_signal = sps.resample(signal, number_of_samples)


    # Number of samples in the resampled signal
    N = resampled_signal.shape[0]

    # Time vector
    t = np.arange(N) / new_rate

    # Frequency vector
    freq_range = np.linspace(0, new_rate/2, N//2)
  
    # Calculate DFT
    dft_signal = dFT(resampled_signal)
    # Plot magnitude spectrum
    plt.figure()
    plt.plot(freq_range, np.abs(dft_signal[:N//2]))
    plt.xlabel('Frequency (Hz)')
    plt.ylabel('Magnitude')
    plt.title('Magnitude Spectrum (fs = {} Hz)'.format(new_rate))
    plt.show()

#filtering of the signals!
# Load the recorded signal from a file
recorded_signal, fs = librosa.load('s4_mohi16000.wav', sr=None)

# Define the filter coefficients
filter_order = 1000
filter_cutoff = 4000 # Hz
filter_coeffs = sps.firwin(filter_order, filter_cutoff, fs=fs)

# Apply the filter to the recorded signal
filtered_signal = sps.convolve(recorded_signal, filter_coeffs, mode='same')

# Plot the recorded and filtered signals
time = np.arange(len(recorded_signal)) / fs

fig, ax = plt.subplots(2, 1, sharex=True, figsize=(8, 6))
ax[0].plot(time, recorded_signal)
ax[0].set_ylabel('Amplitude')
ax[0].set_title('Recorded signal')
ax[1].plot(time, filtered_signal)
ax[1].set_xlabel('Time (s)')
ax[1].set_ylabel('Amplitude')
ax[1].set_title('Filtered signal')
plt.show()

#new new new i guess the correct one!
import numpy as np
from scipy.io import wavfile
import matplotlib.pyplot as plt
import scipy.signal as sps


import librosa

from pydub import AudioSegment
def DFT(x):
    """
    Function to calculate the 
    discrete Fourier Transform 
    of a 1D real-valued signal x
    """

    N = len(x)
    n = np.arange(N)
    k = n.reshape((N, 1))
    e = np.exp(-2j * np.pi * k * n / N)
    
    X = np.dot(e, x)
    
    return X

_, signal = wavfile.read('s1_saurabh500.wav')
# Define the sampling frequencies to analyze
fs = [500]


# Calculate DFT and plot magnitude spectrum for each sampling frequency
for i in fs:
    # Resample the signal
    new_rate = i
    number_of_samples = round(len(signal) * float(new_rate) / _)
    resampled_signal = sps.resample(signal, number_of_samples)

    # Number of samples in the resampled signal
    N = resampled_signal.shape[0]

    # Time vector
    t = np.arange(N) / new_rate

    # Frequency vector
    freq_range = np.linspace(0, new_rate/2, N//2)
  
    # Calculate DFT
    dft_signal = DFT(resampled_signal)
    # Plot magnitude spectrum
    plt.figure()
    plt.plot(freq_range, np.abs(dft_signal[:N//2]))
    plt.xlabel('Frequency (Hz)')
    plt.ylabel('Magnitude')
    plt.title('Magnitude Spectrum (fs = {} Hz)'.format(new_rate))
    plt.show()

#filtering of the signals!
# Load the recorded signal from a file
recorded_signal, fs = librosa.load('s1_saurabh500.wav', sr=None)

# Define the filter coefficients
filter_order = 100
filter_cutoff = 140 # Hz
filter_coeffs = sps.firwin(filter_order, filter_cutoff, fs=fs)

# Apply the filter to the recorded signal
filtered_signal = sps.convolve(recorded_signal, filter_coeffs, mode='same')

# Plot the recorded and filtered signals
time = np.arange(len(recorded_signal)) / fs

fig, ax = plt.subplots(2, 1, sharex=True, figsize=(8, 6))
ax[0].plot(time, recorded_signal)
ax[0].set_ylabel('Amplitude')
ax[0].set_title('Recorded signal')
ax[1].plot(time, filtered_signal)
ax[1].set_xlabel('Time (s)')
ax[1].set_ylabel('Amplitude')
ax[1].set_title('Filtered signal')
plt.show()

#new new new i guess the correct one!
import numpy as np
from scipy.io import wavfile
import matplotlib.pyplot as plt
import scipy.signal as sps


import librosa

from pydub import AudioSegment
def DFT(x):
    """
    Function to calculate the 
    discrete Fourier Transform 
    of a 1D real-valued signal x
    """

    N = len(x)
    n = np.arange(N)
    k = n.reshape((N, 1))
    e = np.exp(-2j * np.pi * k * n / N)
    
    X = np.dot(e, x)
    
    return X

_, signal = wavfile.read('s2_saurabh500.wav')
# Define the sampling frequencies to analyze
fs = [500]


# Calculate DFT and plot magnitude spectrum for each sampling frequency
for i in fs:
    # Resample the signal
    new_rate = i
    number_of_samples = round(len(signal) * float(new_rate) / _)
    resampled_signal = sps.resample(signal, number_of_samples)

    # Number of samples in the resampled signal
    N = resampled_signal.shape[0]

    # Time vector
    t = np.arange(N) / new_rate

    # Frequency vector
    freq_range = np.linspace(0, new_rate/2, N//2)
  
    # Calculate DFT
    dft_signal = DFT(resampled_signal)
    # Plot magnitude spectrum
    plt.figure()
    plt.plot(freq_range, np.abs(dft_signal[:N//2]))
    plt.xlabel('Frequency (Hz)')
    plt.ylabel('Magnitude')
    plt.title('Magnitude Spectrum (fs = {} Hz)'.format(new_rate))
    plt.show()

#filtering of the signals!
# Load the recorded signal from a file
recorded_signal, fs = librosa.load('s2_saurabh500.wav', sr=None)

# Define the filter coefficients
filter_order = 100
filter_cutoff = 140 # Hz
filter_coeffs = sps.firwin(filter_order, filter_cutoff, fs=fs)

# Apply the filter to the recorded signal
filtered_signal = sps.convolve(recorded_signal, filter_coeffs, mode='same')

# Plot the recorded and filtered signals
time = np.arange(len(recorded_signal)) / fs

fig, ax = plt.subplots(2, 1, sharex=True, figsize=(8, 6))
ax[0].plot(time, recorded_signal)
ax[0].set_ylabel('Amplitude')
ax[0].set_title('Recorded signal')
ax[1].plot(time, filtered_signal)
ax[1].set_xlabel('Time (s)')
ax[1].set_ylabel('Amplitude')
ax[1].set_title('Filtered signal')
plt.show()

#new new new i guess the correct one!
import numpy as np
from scipy.io import wavfile
import matplotlib.pyplot as plt
import scipy.signal as sps


import librosa

from pydub import AudioSegment
def DFT(x):
    """
    Function to calculate the 
    discrete Fourier Transform 
    of a 1D real-valued signal x
    """

    N = len(x)
    n = np.arange(N)
    k = n.reshape((N, 1))
    e = np.exp(-2j * np.pi * k * n / N)
    
    X = np.dot(e, x)
    
    return X

_, signal = wavfile.read('s3_saurabh500.wav')
# Define the sampling frequencies to analyze
fs = [500]


# Calculate DFT and plot magnitude spectrum for each sampling frequency
for i in fs:
    # Resample the signal
    new_rate = i
    number_of_samples = round(len(signal) * float(new_rate) / _)
    resampled_signal = sps.resample(signal, number_of_samples)

    # Number of samples in the resampled signal
    N = resampled_signal.shape[0]

    # Time vector
    t = np.arange(N) / new_rate

    # Frequency vector
    freq_range = np.linspace(0, new_rate/2, N//2)
  
    # Calculate DFT
    dft_signal = DFT(resampled_signal)
    # Plot magnitude spectrum
    plt.figure()
    plt.plot(freq_range, np.abs(dft_signal[:N//2]))
    plt.xlabel('Frequency (Hz)')
    plt.ylabel('Magnitude')
    plt.title('Magnitude Spectrum (fs = {} Hz)'.format(new_rate))
    plt.show()

#filtering of the signals!
# Load the recorded signal from a file
recorded_signal, fs = librosa.load('s3_saurabh500.wav', sr=None)

# Define the filter coefficients
filter_order = 100
filter_cutoff = 160 # Hz
filter_coeffs = sps.firwin(filter_order, filter_cutoff, fs=fs)

# Apply the filter to the recorded signal
filtered_signal = sps.convolve(recorded_signal, filter_coeffs, mode='same')

# Plot the recorded and filtered signals
time = np.arange(len(recorded_signal)) / fs

fig, ax = plt.subplots(2, 1, sharex=True, figsize=(8, 6))
ax[0].plot(time, recorded_signal)
ax[0].set_ylabel('Amplitude')
ax[0].set_title('Recorded signal')
ax[1].plot(time, filtered_signal)
ax[1].set_xlabel('Time (s)')
ax[1].set_ylabel('Amplitude')
ax[1].set_title('Filtered signal')
plt.show()

#new new new i guess the correct one!
import numpy as np
from scipy.io import wavfile
import matplotlib.pyplot as plt
import scipy.signal as sps


import librosa

from pydub import AudioSegment
def DFT(x):
    """
    Function to calculate the 
    discrete Fourier Transform 
    of a 1D real-valued signal x
    """

    N = len(x)
    n = np.arange(N)
    k = n.reshape((N, 1))
    e = np.exp(-2j * np.pi * k * n / N)
    
    X = np.dot(e, x)
    
    return X

_, signal = wavfile.read('s4_saurabh500.wav')
# Define the sampling frequencies to analyze
fs = [500]


# Calculate DFT and plot magnitude spectrum for each sampling frequency
for i in fs:
    # Resample the signal
    new_rate = i
    number_of_samples = round(len(signal) * float(new_rate) / _)
    resampled_signal = sps.resample(signal, number_of_samples)

    # Number of samples in the resampled signal
    N = resampled_signal.shape[0]

    # Time vector
    t = np.arange(N) / new_rate

    # Frequency vector
    freq_range = np.linspace(0, new_rate/2, N//2)
  
    # Calculate DFT
    dft_signal = DFT(resampled_signal)
    # Plot magnitude spectrum
    plt.figure()
    plt.plot(freq_range, np.abs(dft_signal[:N//2]))
    plt.xlabel('Frequency (Hz)')
    plt.ylabel('Magnitude')
    plt.title('Magnitude Spectrum (fs = {} Hz)'.format(new_rate))
    plt.show()

#filtering of the signals!
# Load the recorded signal from a file
recorded_signal, fs = librosa.load('s4_saurabh500.wav', sr=None)

# Define the filter coefficients
filter_order = 100
filter_cutoff = 160 # Hz
filter_coeffs = sps.firwin(filter_order, filter_cutoff, fs=fs)

# Apply the filter to the recorded signal
filtered_signal = sps.convolve(recorded_signal, filter_coeffs, mode='same')

# Plot the recorded and filtered signals
time = np.arange(len(recorded_signal)) / fs

fig, ax = plt.subplots(2, 1, sharex=True, figsize=(8, 6))
ax[0].plot(time, recorded_signal)
ax[0].set_ylabel('Amplitude')
ax[0].set_title('Recorded signal')
ax[1].plot(time, filtered_signal)
ax[1].set_xlabel('Time (s)')
ax[1].set_ylabel('Amplitude')
ax[1].set_title('Filtered signal')
plt.show()

#new new new i guess the correct one!
import numpy as np
from scipy.io import wavfile
import matplotlib.pyplot as plt
import scipy.signal as sps


import librosa

from pydub import AudioSegment
def DFT(x):
    """
    Function to calculate the 
    discrete Fourier Transform 
    of a 1D real-valued signal x
    """

    N = len(x)
    n = np.arange(N)
    k = n.reshape((N, 1))
    e = np.exp(-2j * np.pi * k * n / N)
    
    X = np.dot(e, x)
    
    return X

_, signal = wavfile.read('s1_saurabh2000.wav')
# Define the sampling frequencies to analyze
fs = [2000]


# Calculate DFT and plot magnitude spectrum for each sampling frequency
for i in fs:
    # Resample the signal
    new_rate = i
    number_of_samples = round(len(signal) * float(new_rate) / _)
    resampled_signal = sps.resample(signal, number_of_samples)

    # Number of samples in the resampled signal
    N = resampled_signal.shape[0]

    # Time vector
    t = np.arange(N) / new_rate

    # Frequency vector
    freq_range = np.linspace(0, new_rate/2, N//2)
  
    # Calculate DFT
    dft_signal = DFT(resampled_signal)
    # Plot magnitude spectrum
    plt.figure()
    plt.plot(freq_range, np.abs(dft_signal[:N//2]))
    plt.xlabel('Frequency (Hz)')
    plt.ylabel('Magnitude')
    plt.title('Magnitude Spectrum (fs = {} Hz)'.format(new_rate))
    plt.show()

#filtering of the signals!
# Load the recorded signal from a file
recorded_signal, fs = librosa.load('s1_saurabh2000.wav', sr=None)

# Define the filter coefficients
filter_order = 1000
filter_cutoff = 700 # Hz
filter_coeffs = sps.firwin(filter_order, filter_cutoff, fs=fs)

# Apply the filter to the recorded signal
filtered_signal = sps.convolve(recorded_signal, filter_coeffs, mode='same')

# Plot the recorded and filtered signals
time = np.arange(len(recorded_signal)) / fs

fig, ax = plt.subplots(2, 1, sharex=True, figsize=(8, 6))
ax[0].plot(time, recorded_signal)
ax[0].set_ylabel('Amplitude')
ax[0].set_title('Recorded signal')
ax[1].plot(time, filtered_signal)
ax[1].set_xlabel('Time (s)')
ax[1].set_ylabel('Amplitude')
ax[1].set_title('Filtered signal')
plt.show()

#new new new i guess the correct one!
import numpy as np
from scipy.io import wavfile
import matplotlib.pyplot as plt
import scipy.signal as sps


import librosa

from pydub import AudioSegment
def DFT(x):
    """
    Function to calculate the 
    discrete Fourier Transform 
    of a 1D real-valued signal x
    """

    N = len(x)
    n = np.arange(N)
    k = n.reshape((N, 1))
    e = np.exp(-2j * np.pi * k * n / N)
    
    X = np.dot(e, x)
    
    return X

_, signal = wavfile.read('s2_saurabh2000.wav')
# Define the sampling frequencies to analyze
fs = [2000]


# Calculate DFT and plot magnitude spectrum for each sampling frequency
for i in fs:
    # Resample the signal
    new_rate = i
    number_of_samples = round(len(signal) * float(new_rate) / _)
    resampled_signal = sps.resample(signal, number_of_samples)

    # Number of samples in the resampled signal
    N = resampled_signal.shape[0]

    # Time vector
    t = np.arange(N) / new_rate

    # Frequency vector
    freq_range = np.linspace(0, new_rate/2, N//2)
  
    # Calculate DFT
    dft_signal = DFT(resampled_signal)
    # Plot magnitude spectrum
    plt.figure()
    plt.plot(freq_range, np.abs(dft_signal[:N//2]))
    plt.xlabel('Frequency (Hz)')
    plt.ylabel('Magnitude')
    plt.title('Magnitude Spectrum (fs = {} Hz)'.format(new_rate))
    plt.show()

#filtering of the signals!
# Load the recorded signal from a file
recorded_signal, fs = librosa.load('s2_saurabh2000.wav', sr=None)

# Define the filter coefficients
filter_order = 500
filter_cutoff = 700 # Hz
filter_coeffs = sps.firwin(filter_order, filter_cutoff, fs=fs)

# Apply the filter to the recorded signal
filtered_signal = sps.convolve(recorded_signal, filter_coeffs, mode='same')

# Plot the recorded and filtered signals
time = np.arange(len(recorded_signal)) / fs

fig, ax = plt.subplots(2, 1, sharex=True, figsize=(8, 6))
ax[0].plot(time, recorded_signal)
ax[0].set_ylabel('Amplitude')
ax[0].set_title('Recorded signal')
ax[1].plot(time, filtered_signal)
ax[1].set_xlabel('Time (s)')
ax[1].set_ylabel('Amplitude')
ax[1].set_title('Filtered signal')
plt.show()

#new new new i guess the correct one!
import numpy as np
from scipy.io import wavfile
import matplotlib.pyplot as plt
import scipy.signal as sps


import librosa

from pydub import AudioSegment
def DFT(x):
    """
    Function to calculate the 
    discrete Fourier Transform 
    of a 1D real-valued signal x
    """

    N = len(x)
    n = np.arange(N)
    k = n.reshape((N, 1))
    e = np.exp(-2j * np.pi * k * n / N)
    
    X = np.dot(e, x)
    
    return X

_, signal = wavfile.read('s3_saurabh2000.wav')
# Define the sampling frequencies to analyze
fs = [2000]


# Calculate DFT and plot magnitude spectrum for each sampling frequency
for i in fs:
    # Resample the signal
    new_rate = i
    number_of_samples = round(len(signal) * float(new_rate) / _)
    resampled_signal = sps.resample(signal, number_of_samples)

    # Number of samples in the resampled signal
    N = resampled_signal.shape[0]

    # Time vector
    t = np.arange(N) / new_rate

    # Frequency vector
    freq_range = np.linspace(0, new_rate/2, N//2)
  
    # Calculate DFT
    dft_signal = DFT(resampled_signal)
    # Plot magnitude spectrum
    plt.figure()
    plt.plot(freq_range, np.abs(dft_signal[:N//2]))
    plt.xlabel('Frequency (Hz)')
    plt.ylabel('Magnitude')
    plt.title('Magnitude Spectrum (fs = {} Hz)'.format(new_rate))
    plt.show()

#filtering of the signals!
# Load the recorded signal from a file
recorded_signal, fs = librosa.load('s3_saurabh2000.wav', sr=None)

# Define the filter coefficients
filter_order = 1000
filter_cutoff = 700 # Hz
filter_coeffs = sps.firwin(filter_order, filter_cutoff, fs=fs)

# Apply the filter to the recorded signal
filtered_signal = sps.convolve(recorded_signal, filter_coeffs, mode='same')

# Plot the recorded and filtered signals
time = np.arange(len(recorded_signal)) / fs

fig, ax = plt.subplots(2, 1, sharex=True, figsize=(8, 6))
ax[0].plot(time, recorded_signal)
ax[0].set_ylabel('Amplitude')
ax[0].set_title('Recorded signal')
ax[1].plot(time, filtered_signal)
ax[1].set_xlabel('Time (s)')
ax[1].set_ylabel('Amplitude')
ax[1].set_title('Filtered signal')
plt.show()

#new new new i guess the correct one!
import numpy as np
from scipy.io import wavfile
import matplotlib.pyplot as plt
import scipy.signal as sps


import librosa

from pydub import AudioSegment
def DFT(x):
    """
    Function to calculate the 
    discrete Fourier Transform 
    of a 1D real-valued signal x
    """

    N = len(x)
    n = np.arange(N)
    k = n.reshape((N, 1))
    e = np.exp(-2j * np.pi * k * n / N)
    
    X = np.dot(e, x)
    
    return X

_, signal = wavfile.read('s4_saurabh2000.wav')
# Define the sampling frequencies to analyze
fs = [2000]


# Calculate DFT and plot magnitude spectrum for each sampling frequency
for i in fs:
    # Resample the signal
    new_rate = i
    number_of_samples = round(len(signal) * float(new_rate) / _)
    from numpy.fft import fft as dFT
    resampled_signal = sps.resample(signal, number_of_samples)

    # Number of samples in the resampled signal
    N = resampled_signal.shape[0]

    # Time vector
    t = np.arange(N) / new_rate

    # Frequency vector
    freq_range = np.linspace(0, new_rate/2, N//2)
  
    # Calculate DFT
    dft_signal = dFT(resampled_signal)
    # Plot magnitude spectrum
    plt.figure()
    plt.plot(freq_range, np.abs(dft_signal[:N//2]))
    plt.xlabel('Frequency (Hz)')
    plt.ylabel('Magnitude')
    plt.title('Magnitude Spectrum (fs = {} Hz)'.format(new_rate))
    plt.show()

#filtering of the signals!
# Load the recorded signal from a file
recorded_signal, fs = librosa.load('s4_saurabh2000.wav', sr=None)

# Define the filter coefficients
filter_order = 1000
filter_cutoff = 700 # Hz
filter_coeffs = sps.firwin(filter_order, filter_cutoff, fs=fs)

# Apply the filter to the recorded signal
filtered_signal = sps.convolve(recorded_signal, filter_coeffs, mode='same')

# Plot the recorded and filtered signals
time = np.arange(len(recorded_signal)) / fs

fig, ax = plt.subplots(2, 1, sharex=True, figsize=(8, 6))
ax[0].plot(time, recorded_signal)
ax[0].set_ylabel('Amplitude')
ax[0].set_title('Recorded signal')
ax[1].plot(time, filtered_signal)
ax[1].set_xlabel('Time (s)')
ax[1].set_ylabel('Amplitude')
ax[1].set_title('Filtered signal')
plt.show()

#new new new i guess the correct one!
import numpy as np
from scipy.io import wavfile
import matplotlib.pyplot as plt
import scipy.signal as sps


import librosa

from pydub import AudioSegment
def DFT(x):
    """
    Function to calculate the 
    discrete Fourier Transform 
    of a 1D real-valued signal x
    """

    N = len(x)
    n = np.arange(N)
    k = n.reshape((N, 1))
    e = np.exp(-2j * np.pi * k * n / N)
    
    X = np.dot(e, x)
    
    return X

_, signal = wavfile.read('s1_saurabh16000.wav')
# Define the sampling frequencies to analyze
fs = [16000]


# Calculate DFT and plot magnitude spectrum for each sampling frequency
for i in fs:
    # Resample the signal
    new_rate = i
    number_of_samples = round(len(signal) * float(new_rate) / _)
    resampled_signal = sps.resample(signal, number_of_samples)

    # Number of samples in the resampled signal
    N = resampled_signal.shape[0]

    # Time vector
    t = np.arange(N) / new_rate

    # Frequency vector
    freq_range = np.linspace(0, new_rate/2, N//2)
  
    # Calculate DFT
    dft_signal = DFT(resampled_signal)
    # Plot magnitude spectrum
    plt.figure()
    plt.plot(freq_range, np.abs(dft_signal[:N//2]))
    plt.xlabel('Frequency (Hz)')
    plt.ylabel('Magnitude')
    plt.title('Magnitude Spectrum (fs = {} Hz)'.format(new_rate))
    plt.show()

#filtering of the signals!
# Load the recorded signal from a file
recorded_signal, fs = librosa.load('s1_saurabh16000.wav', sr=None)

# Define the filter coefficients
filter_order = 10000
filter_cutoff = 4000 # Hz
filter_coeffs = sps.firwin(filter_order, filter_cutoff, fs=fs)

# Apply the filter to the recorded signal
filtered_signal = sps.convolve(recorded_signal, filter_coeffs, mode='same')

# Plot the recorded and filtered signals
time = np.arange(len(recorded_signal)) / fs

fig, ax = plt.subplots(2, 1, sharex=True, figsize=(8, 6))
ax[0].plot(time, recorded_signal)
ax[0].set_ylabel('Amplitude')
ax[0].set_title('Recorded signal')
ax[1].plot(time, filtered_signal)
ax[1].set_xlabel('Time (s)')
ax[1].set_ylabel('Amplitude')
ax[1].set_title('Filtered signal')
plt.show()

#new new new i guess the correct one!
import numpy as np
from scipy.io import wavfile
import matplotlib.pyplot as plt
import scipy.signal as sps


import librosa

from pydub import AudioSegment
def DFT(x):
    """
    Function to calculate the 
    discrete Fourier Transform 
    of a 1D real-valued signal x
    """

    N = len(x)
    n = np.arange(N)
    k = n.reshape((N, 1))
    e = np.exp(-2j * np.pi * k * n / N)
    
    X = np.dot(e, x)
    
    return X

_, signal = wavfile.read('s2_saurabh16000.wav')
# Define the sampling frequencies to analyze
fs = [16000]


# Calculate DFT and plot magnitude spectrum for each sampling frequency
for i in fs:
    # Resample the signal
    new_rate = i
    number_of_samples = round(len(signal) * float(new_rate) / _)
    resampled_signal = sps.resample(signal, number_of_samples)

    # Number of samples in the resampled signal
    N = resampled_signal.shape[0]

    # Time vector
    t = np.arange(N) / new_rate

    # Frequency vector
    freq_range = np.linspace(0, new_rate/2, N//2)
  
    # Calculate DFT
    dft_signal = DFT(resampled_signal)
    # Plot magnitude spectrum
    plt.figure()
    plt.plot(freq_range, np.abs(dft_signal[:N//2]))
    plt.xlabel('Frequency (Hz)')
    plt.ylabel('Magnitude')
    plt.title('Magnitude Spectrum (fs = {} Hz)'.format(new_rate))
    plt.show()

#filtering of the signals!
# Load the recorded signal from a file
recorded_signal, fs = librosa.load('s2_saurabh16000.wav', sr=None)

# Define the filter coefficients
filter_order = 10000
filter_cutoff = 4000 # Hz
filter_coeffs = sps.firwin(filter_order, filter_cutoff, fs=fs)

# Apply the filter to the recorded signal
filtered_signal = sps.convolve(recorded_signal, filter_coeffs, mode='same')

# Plot the recorded and filtered signals
time = np.arange(len(recorded_signal)) / fs

fig, ax = plt.subplots(2, 1, sharex=True, figsize=(8, 6))
ax[0].plot(time, recorded_signal)
ax[0].set_ylabel('Amplitude')
ax[0].set_title('Recorded signal')
ax[1].plot(time, filtered_signal)
ax[1].set_xlabel('Time (s)')
ax[1].set_ylabel('Amplitude')
ax[1].set_title('Filtered signal')
plt.show()

#new new new i guess the correct one!
import numpy as np
from scipy.io import wavfile
import matplotlib.pyplot as plt
import scipy.signal as sps


import librosa

from pydub import AudioSegment
def DFT(x):
    """
    Function to calculate the 
    discrete Fourier Transform 
    of a 1D real-valued signal x
    """

    N = len(x)
    n = np.arange(N)
    k = n.reshape((N, 1))
    e = np.exp(-2j * np.pi * k * n / N)
    
    X = np.dot(e, x)
    
    return X

_, signal = wavfile.read('s3_saurabh16000.wav')
# Define the sampling frequencies to analyze
fs = [16000]


# Calculate DFT and plot magnitude spectrum for each sampling frequency
for i in fs:
    # Resample the signal
    new_rate = i
    number_of_samples = round(len(signal) * float(new_rate) / _)
    resampled_signal = sps.resample(signal, number_of_samples)

    # Number of samples in the resampled signal
    N = resampled_signal.shape[0]

    # Time vector
    t = np.arange(N) / new_rate

    # Frequency vector
    freq_range = np.linspace(0, new_rate/2, N//2)
  
    # Calculate DFT
    dft_signal = DFT(resampled_signal)
    # Plot magnitude spectrum
    plt.figure()
    plt.plot(freq_range, np.abs(dft_signal[:N//2]))
    plt.xlabel('Frequency (Hz)')
    plt.ylabel('Magnitude')
    plt.title('Magnitude Spectrum (fs = {} Hz)'.format(new_rate))
    plt.show()

#filtering of the signals!
# Load the recorded signal from a file
recorded_signal, fs = librosa.load('s3_saurabh16000.wav', sr=None)

# Define the filter coefficients
filter_order = 10000
filter_cutoff = 4000 # Hz
filter_coeffs = sps.firwin(filter_order, filter_cutoff, fs=fs)

# Apply the filter to the recorded signal
filtered_signal = sps.convolve(recorded_signal, filter_coeffs, mode='same')

# Plot the recorded and filtered signals
time = np.arange(len(recorded_signal)) / fs

fig, ax = plt.subplots(2, 1, sharex=True, figsize=(8, 6))
ax[0].plot(time, recorded_signal)
ax[0].set_ylabel('Amplitude')
ax[0].set_title('Recorded signal')
ax[1].plot(time, filtered_signal)
ax[1].set_xlabel('Time (s)')
ax[1].set_ylabel('Amplitude')
ax[1].set_title('Filtered signal')
plt.show()

#new new new i guess the correct one!
import numpy as np
from scipy.io import wavfile
import matplotlib.pyplot as plt
import scipy.signal as sps


import librosa

from pydub import AudioSegment
def DFT(x):
    """
    Function to calculate the 
    discrete Fourier Transform 
    of a 1D real-valued signal x
    """

    N = len(x)
    n = np.arange(N)
    k = n.reshape((N, 1))
    e = np.exp(-2j * np.pi * k * n / N)
    
    X = np.dot(e, x)
    
    return X

_, signal = wavfile.read('s4_saurabh16000.wav')
# Define the sampling frequencies to analyze
fs = [16000]


# Calculate DFT and plot magnitude spectrum for each sampling frequency
for i in fs:
    # Resample the signal
    new_rate = i
    number_of_samples = round(len(signal) * float(new_rate) / _)
    resampled_signal = sps.resample(signal, number_of_samples)

    # Number of samples in the resampled signal
    N = resampled_signal.shape[0]

    # Time vector
    t = np.arange(N) / new_rate

    # Frequency vector
    freq_range = np.linspace(0, new_rate/2, N//2)
  
    # Calculate DFT
    dft_signal = DFT(resampled_signal)
    # Plot magnitude spectrum
    plt.figure()
    plt.plot(freq_range, np.abs(dft_signal[:N//2]))
    plt.xlabel('Frequency (Hz)')
    plt.ylabel('Magnitude')
    plt.title('Magnitude Spectrum (fs = {} Hz)'.format(new_rate))
    plt.show()

#filtering of the signals!
# Load the recorded signal from a file
recorded_signal, fs = librosa.load('s4_saurabh16000.wav', sr=None)

# Define the filter coefficients
filter_order = 10000
filter_cutoff = 4000 # Hz
filter_coeffs = sps.firwin(filter_order, filter_cutoff, fs=fs)

# Apply the filter to the recorded signal
filtered_signal = sps.convolve(recorded_signal, filter_coeffs, mode='same')

# Plot the recorded and filtered signals
time = np.arange(len(recorded_signal)) / fs

fig, ax = plt.subplots(2, 1, sharex=True, figsize=(8, 6))
ax[0].plot(time, recorded_signal)
ax[0].set_ylabel('Amplitude')
ax[0].set_title('Recorded signal')
ax[1].plot(time, filtered_signal)
ax[1].set_xlabel('Time (s)')
ax[1].set_ylabel('Amplitude')
ax[1].set_title('Filtered signal')
plt.show()

#new new new i guess the correct one!
import numpy as np
from scipy.io import wavfile
import matplotlib.pyplot as plt
import scipy.signal as sps


import librosa

from pydub import AudioSegment
def DFT(x):
    """
    Function to calculate the 
    discrete Fourier Transform 
    of a 1D real-valued signal x
    """

    N = len(x)
    n = np.arange(N)
    k = n.reshape((N, 1))
    e = np.exp(-2j * np.pi * k * n / N)
    
    X = np.dot(e, x)
    
    return X

_, signal = wavfile.read('s1_vikash500.wav')
# Define the sampling frequencies to analyze
fs = [500]


# Calculate DFT and plot magnitude spectrum for each sampling frequency
for i in fs:
    # Resample the signal
    new_rate = i
    number_of_samples = round(len(signal) * float(new_rate) / _)
    resampled_signal = sps.resample(signal, number_of_samples)

    # Number of samples in the resampled signal
    N = resampled_signal.shape[0]

    # Time vector
    t = np.arange(N) / new_rate

    # Frequency vector
    freq_range = np.linspace(0, new_rate/2, N//2)
  
    # Calculate DFT
    dft_signal = DFT(resampled_signal)
    # Plot magnitude spectrum
    plt.figure()
    plt.plot(freq_range, np.abs(dft_signal[:N//2]))
    plt.xlabel('Frequency (Hz)')
    plt.ylabel('Magnitude')
    plt.title('Magnitude Spectrum (fs = {} Hz)'.format(new_rate))
    plt.show()

#filtering of the signals!
# Load the recorded signal from a file
recorded_signal, fs = librosa.load('s1_vikash500.wav', sr=None)

# Define the filter coefficients
filter_order = 100
filter_cutoff = 160 # Hz
filter_coeffs = sps.firwin(filter_order, filter_cutoff, fs=fs)

# Apply the filter to the recorded signal
filtered_signal = sps.convolve(recorded_signal, filter_coeffs, mode='same')

# Plot the recorded and filtered signals
time = np.arange(len(recorded_signal)) / fs

fig, ax = plt.subplots(2, 1, sharex=True, figsize=(8, 6))
ax[0].plot(time, recorded_signal)
ax[0].set_ylabel('Amplitude')
ax[0].set_title('Recorded signal')
ax[1].plot(time, filtered_signal)
ax[1].set_xlabel('Time (s)')
ax[1].set_ylabel('Amplitude')
ax[1].set_title('Filtered signal')
plt.show()

#new new new i guess the correct one!
import numpy as np
from scipy.io import wavfile
import matplotlib.pyplot as plt
import scipy.signal as sps


import librosa

from pydub import AudioSegment
def DFT(x):
    """
    Function to calculate the 
    discrete Fourier Transform 
    of a 1D real-valued signal x
    """

    N = len(x)
    n = np.arange(N)
    k = n.reshape((N, 1))
    e = np.exp(-2j * np.pi * k * n / N)
    
    X = np.dot(e, x)
    
    return X

_, signal = wavfile.read('s2_vikash500.wav')
# Define the sampling frequencies to analyze
fs = [500]


# Calculate DFT and plot magnitude spectrum for each sampling frequency
for i in fs:
    # Resample the signal
    new_rate = i
    number_of_samples = round(len(signal) * float(new_rate) / _)
    resampled_signal = sps.resample(signal, number_of_samples)

    # Number of samples in the resampled signal
    N = resampled_signal.shape[0]

    # Time vector
    t = np.arange(N) / new_rate

    # Frequency vector
    freq_range = np.linspace(0, new_rate/2, N//2)
  
    # Calculate DFT
    dft_signal = DFT(resampled_signal)
    # Plot magnitude spectrum
    plt.figure()
    plt.plot(freq_range, np.abs(dft_signal[:N//2]))
    plt.xlabel('Frequency (Hz)')
    plt.ylabel('Magnitude')
    plt.title('Magnitude Spectrum (fs = {} Hz)'.format(new_rate))
    plt.show()

#filtering of the signals!
# Load the recorded signal from a file
recorded_signal, fs = librosa.load('s2_vikash500.wav', sr=None)

# Define the filter coefficients
filter_order = 100
filter_cutoff = 160 # Hz
filter_coeffs = sps.firwin(filter_order, filter_cutoff, fs=fs)

# Apply the filter to the recorded signal
filtered_signal = sps.convolve(recorded_signal, filter_coeffs, mode='same')

# Plot the recorded and filtered signals
time = np.arange(len(recorded_signal)) / fs

fig, ax = plt.subplots(2, 1, sharex=True, figsize=(8, 6))
ax[0].plot(time, recorded_signal)
ax[0].set_ylabel('Amplitude')
ax[0].set_title('Recorded signal')
ax[1].plot(time, filtered_signal)
ax[1].set_xlabel('Time (s)')
ax[1].set_ylabel('Amplitude')
ax[1].set_title('Filtered signal')
plt.show()

#new new new i guess the correct one!
import numpy as np
from scipy.io import wavfile
import matplotlib.pyplot as plt
import scipy.signal as sps


import librosa

from pydub import AudioSegment
def DFT(x):
    """
    Function to calculate the 
    discrete Fourier Transform 
    of a 1D real-valued signal x
    """

    N = len(x)
    n = np.arange(N)
    k = n.reshape((N, 1))
    e = np.exp(-2j * np.pi * k * n / N)
    
    X = np.dot(e, x)
    
    return X

_, signal = wavfile.read('s3_vikash500.wav')
# Define the sampling frequencies to analyze
fs = [500]


# Calculate DFT and plot magnitude spectrum for each sampling frequency
for i in fs:
    # Resample the signal
    new_rate = i
    number_of_samples = round(len(signal) * float(new_rate) / _)
    resampled_signal = sps.resample(signal, number_of_samples)

    # Number of samples in the resampled signal
    N = resampled_signal.shape[0]

    # Time vector
    t = np.arange(N) / new_rate

    # Frequency vector
    freq_range = np.linspace(0, new_rate/2, N//2)
  
    # Calculate DFT
    dft_signal = DFT(resampled_signal)
    # Plot magnitude spectrum
    plt.figure()
    plt.plot(freq_range, np.abs(dft_signal[:N//2]))
    plt.xlabel('Frequency (Hz)')
    plt.ylabel('Magnitude')
    plt.title('Magnitude Spectrum (fs = {} Hz)'.format(new_rate))
    plt.show()

#filtering of the signals!
# Load the recorded signal from a file
recorded_signal, fs = librosa.load('s3_vikash500.wav', sr=None)

# Define the filter coefficients
filter_order = 100
filter_cutoff = 160 # Hz
filter_coeffs = sps.firwin(filter_order, filter_cutoff, fs=fs)

# Apply the filter to the recorded signal
filtered_signal = sps.convolve(recorded_signal, filter_coeffs, mode='same')

# Plot the recorded and filtered signals
time = np.arange(len(recorded_signal)) / fs

fig, ax = plt.subplots(2, 1, sharex=True, figsize=(8, 6))
ax[0].plot(time, recorded_signal)
ax[0].set_ylabel('Amplitude')
ax[0].set_title('Recorded signal')
ax[1].plot(time, filtered_signal)
ax[1].set_xlabel('Time (s)')
ax[1].set_ylabel('Amplitude')
ax[1].set_title('Filtered signal')
plt.show()

#new new new i guess the correct one!
import numpy as np
from scipy.io import wavfile
import matplotlib.pyplot as plt
import scipy.signal as sps


import librosa

from pydub import AudioSegment
def DFT(x):
    """
    Function to calculate the 
    discrete Fourier Transform 
    of a 1D real-valued signal x
    """

    N = len(x)
    n = np.arange(N)
    k = n.reshape((N, 1))
    e = np.exp(-2j * np.pi * k * n / N)
    
    X = np.dot(e, x)
    
    return X

_, signal = wavfile.read('s4_vikash500.wav')
# Define the sampling frequencies to analyze
fs = [500]


# Calculate DFT and plot magnitude spectrum for each sampling frequency
for i in fs:
    # Resample the signal
    new_rate = i
    number_of_samples = round(len(signal) * float(new_rate) / _)
    resampled_signal = sps.resample(signal, number_of_samples)

    # Number of samples in the resampled signal
    N = resampled_signal.shape[0]

    # Time vector
    t = np.arange(N) / new_rate

    # Frequency vector
    freq_range = np.linspace(0, new_rate/2, N//2)
  
    # Calculate DFT
    dft_signal = DFT(resampled_signal)
    # Plot magnitude spectrum
    plt.figure()
    plt.plot(freq_range, np.abs(dft_signal[:N//2]))
    plt.xlabel('Frequency (Hz)')
    plt.ylabel('Magnitude')
    plt.title('Magnitude Spectrum (fs = {} Hz)'.format(new_rate))
    plt.show()

#filtering of the signals!
# Load the recorded signal from a file
recorded_signal, fs = librosa.load('s4_vikash500.wav', sr=None)

# Define the filter coefficients
filter_order = 100
filter_cutoff = 160 # Hz
filter_coeffs = sps.firwin(filter_order, filter_cutoff, fs=fs)

# Apply the filter to the recorded signal
filtered_signal = sps.convolve(recorded_signal, filter_coeffs, mode='same')

# Plot the recorded and filtered signals
time = np.arange(len(recorded_signal)) / fs

fig, ax = plt.subplots(2, 1, sharex=True, figsize=(8, 6))
ax[0].plot(time, recorded_signal)
ax[0].set_ylabel('Amplitude')
ax[0].set_title('Recorded signal')
ax[1].plot(time, filtered_signal)
ax[1].set_xlabel('Time (s)')
ax[1].set_ylabel('Amplitude')
ax[1].set_title('Filtered signal')
plt.show()

#new new new i guess the correct one!
import numpy as np
from scipy.io import wavfile
import matplotlib.pyplot as plt
import scipy.signal as sps


import librosa

from pydub import AudioSegment
def DFT(x):
    """
    Function to calculate the 
    discrete Fourier Transform 
    of a 1D real-valued signal x
    """

    N = len(x)
    n = np.arange(N)
    k = n.reshape((N, 1))
    e = np.exp(-2j * np.pi * k * n / N)
    
    X = np.dot(e, x)
    
    return X

_, signal = wavfile.read('s1_vikash2000.wav')
# Define the sampling frequencies to analyze
fs = [2000]


# Calculate DFT and plot magnitude spectrum for each sampling frequency
for i in fs:
    # Resample the signal
    new_rate = i
    number_of_samples = round(len(signal) * float(new_rate) / _)
    resampled_signal = sps.resample(signal, number_of_samples)

    # Number of samples in the resampled signal
    N = resampled_signal.shape[0]

    # Time vector
    t = np.arange(N) / new_rate

    # Frequency vector
    freq_range = np.linspace(0, new_rate/2, N//2)
  
    # Calculate DFT
    dft_signal = DFT(resampled_signal)
    # Plot magnitude spectrum
    plt.figure()
    plt.plot(freq_range, np.abs(dft_signal[:N//2]))
    plt.xlabel('Frequency (Hz)')
    plt.ylabel('Magnitude')
    plt.title('Magnitude Spectrum (fs = {} Hz)'.format(new_rate))
    plt.show()

#filtering of the signals!
# Load the recorded signal from a file
recorded_signal, fs = librosa.load('s1_vikash2000.wav', sr=None)

# Define the filter coefficients
filter_order = 100
filter_cutoff = 400 # Hz
filter_coeffs = sps.firwin(filter_order, filter_cutoff, fs=fs)

# Apply the filter to the recorded signal
filtered_signal = sps.convolve(recorded_signal, filter_coeffs, mode='same')

# Plot the recorded and filtered signals
time = np.arange(len(recorded_signal)) / fs

fig, ax = plt.subplots(2, 1, sharex=True, figsize=(8, 6))
ax[0].plot(time, recorded_signal)
ax[0].set_ylabel('Amplitude')
ax[0].set_title('Recorded signal')
ax[1].plot(time, filtered_signal)
ax[1].set_xlabel('Time (s)')
ax[1].set_ylabel('Amplitude')
ax[1].set_title('Filtered signal')
plt.show()

#new new new i guess the correct one!
import numpy as np
from scipy.io import wavfile
import matplotlib.pyplot as plt
import scipy.signal as sps


import librosa

from pydub import AudioSegment
def DFT(x):
    """
    Function to calculate the 
    discrete Fourier Transform 
    of a 1D real-valued signal x
    """

    N = len(x)
    n = np.arange(N)
    k = n.reshape((N, 1))
    e = np.exp(-2j * np.pi * k * n / N)
    
    X = np.dot(e, x)
    
    return X

_, signal = wavfile.read('s2_vikash2000.wav')
# Define the sampling frequencies to analyze
fs = [2000]


# Calculate DFT and plot magnitude spectrum for each sampling frequency
for i in fs:
    # Resample the signal
    new_rate = i
    number_of_samples = round(len(signal) * float(new_rate) / _)
    resampled_signal = sps.resample(signal, number_of_samples)

    # Number of samples in the resampled signal
    N = resampled_signal.shape[0]

    # Time vector
    t = np.arange(N) / new_rate

    # Frequency vector
    freq_range = np.linspace(0, new_rate/2, N//2)
  
    # Calculate DFT
    dft_signal = DFT(resampled_signal)
    # Plot magnitude spectrum
    plt.figure()
    plt.plot(freq_range, np.abs(dft_signal[:N//2]))
    plt.xlabel('Frequency (Hz)')
    plt.ylabel('Magnitude')
    plt.title('Magnitude Spectrum (fs = {} Hz)'.format(new_rate))
    plt.show()

#filtering of the signals!
# Load the recorded signal from a file
recorded_signal, fs = librosa.load('s2_vikash2000.wav', sr=None)

# Define the filter coefficients
filter_order = 100
filter_cutoff = 400 # Hz
filter_coeffs = sps.firwin(filter_order, filter_cutoff, fs=fs)

# Apply the filter to the recorded signal
filtered_signal = sps.convolve(recorded_signal, filter_coeffs, mode='same')

# Plot the recorded and filtered signals
time = np.arange(len(recorded_signal)) / fs

fig, ax = plt.subplots(2, 1, sharex=True, figsize=(8, 6))
ax[0].plot(time, recorded_signal)
ax[0].set_ylabel('Amplitude')
ax[0].set_title('Recorded signal')
ax[1].plot(time, filtered_signal)
ax[1].set_xlabel('Time (s)')
ax[1].set_ylabel('Amplitude')
ax[1].set_title('Filtered signal')
plt.show()

#new new new i guess the correct one!
import numpy as np
from scipy.io import wavfile
import matplotlib.pyplot as plt
import scipy.signal as sps


import librosa

from pydub import AudioSegment
def DFT(x):
    """
    Function to calculate the 
    discrete Fourier Transform 
    of a 1D real-valued signal x
    """

    N = len(x)
    n = np.arange(N)
    k = n.reshape((N, 1))
    e = np.exp(-2j * np.pi * k * n / N)
    
    X = np.dot(e, x)
    
    return X

_, signal = wavfile.read('s3_vikash2000.wav')
# Define the sampling frequencies to analyze
fs = [2000]


# Calculate DFT and plot magnitude spectrum for each sampling frequency
for i in fs:
    # Resample the signal
    new_rate = i
    number_of_samples = round(len(signal) * float(new_rate) / _)
    resampled_signal = sps.resample(signal, number_of_samples)

    # Number of samples in the resampled signal
    N = resampled_signal.shape[0]

    # Time vector
    t = np.arange(N) / new_rate

    # Frequency vector
    freq_range = np.linspace(0, new_rate/2, N//2)
  
    # Calculate DFT
    dft_signal = DFT(resampled_signal)
    # Plot magnitude spectrum
    plt.figure()
    plt.plot(freq_range, np.abs(dft_signal[:N//2]))
    plt.xlabel('Frequency (Hz)')
    plt.ylabel('Magnitude')
    plt.title('Magnitude Spectrum (fs = {} Hz)'.format(new_rate))
    plt.show()

#filtering of the signals!
# Load the recorded signal from a file
recorded_signal, fs = librosa.load('s3_vikash2000.wav', sr=None)

# Define the filter coefficients
filter_order = 100
filter_cutoff = 400 # Hz
filter_coeffs = sps.firwin(filter_order, filter_cutoff, fs=fs)

# Apply the filter to the recorded signal
filtered_signal = sps.convolve(recorded_signal, filter_coeffs, mode='same')

# Plot the recorded and filtered signals
time = np.arange(len(recorded_signal)) / fs

fig, ax = plt.subplots(2, 1, sharex=True, figsize=(8, 6))
ax[0].plot(time, recorded_signal)
ax[0].set_ylabel('Amplitude')
ax[0].set_title('Recorded signal')
ax[1].plot(time, filtered_signal)
ax[1].set_xlabel('Time (s)')
ax[1].set_ylabel('Amplitude')
ax[1].set_title('Filtered signal')
plt.show()

#new new new i guess the correct one!
import numpy as np
from scipy.io import wavfile
import matplotlib.pyplot as plt
import scipy.signal as sps


import librosa

from pydub import AudioSegment
def DFT(x):
    """
    Function to calculate the 
    discrete Fourier Transform 
    of a 1D real-valued signal x
    """

    N = len(x)
    n = np.arange(N)
    k = n.reshape((N, 1))
    e = np.exp(-2j * np.pi * k * n / N)
    
    X = np.dot(e, x)
    
    return X

_, signal = wavfile.read('s4_vikash2000.wav')
# Define the sampling frequencies to analyze
fs = [2000]


# Calculate DFT and plot magnitude spectrum for each sampling frequency
for i in fs:
    # Resample the signal
    new_rate = i
    number_of_samples = round(len(signal) * float(new_rate) / _)
    resampled_signal = sps.resample(signal, number_of_samples)

    # Number of samples in the resampled signal
    N = resampled_signal.shape[0]

    # Time vector
    t = np.arange(N) / new_rate

    # Frequency vector
    freq_range = np.linspace(0, new_rate/2, N//2)
  
    # Calculate DFT
    dft_signal = DFT(resampled_signal)
    # Plot magnitude spectrum
    plt.figure()
    plt.plot(freq_range, np.abs(dft_signal[:N//2]))
    plt.xlabel('Frequency (Hz)')
    plt.ylabel('Magnitude')
    plt.title('Magnitude Spectrum (fs = {} Hz)'.format(new_rate))
    plt.show()

#filtering of the signals!
# Load the recorded signal from a file
recorded_signal, fs = librosa.load('s4_vikash2000.wav', sr=None)

# Define the filter coefficients
filter_order = 100
filter_cutoff = 400 # Hz
filter_coeffs = sps.firwin(filter_order, filter_cutoff, fs=fs)

# Apply the filter to the recorded signal
filtered_signal = sps.convolve(recorded_signal, filter_coeffs, mode='same')

# Plot the recorded and filtered signals
time = np.arange(len(recorded_signal)) / fs

fig, ax = plt.subplots(2, 1, sharex=True, figsize=(8, 6))
ax[0].plot(time, recorded_signal)
ax[0].set_ylabel('Amplitude')
ax[0].set_title('Recorded signal')
ax[1].plot(time, filtered_signal)
ax[1].set_xlabel('Time (s)')
ax[1].set_ylabel('Amplitude')
ax[1].set_title('Filtered signal')
plt.show()

#new new new i guess the correct one!
import numpy as np
from scipy.io import wavfile
import matplotlib.pyplot as plt
import scipy.signal as sps


import librosa

from pydub import AudioSegment
def DFT(x):
    """
    Function to calculate the 
    discrete Fourier Transform 
    of a 1D real-valued signal x
    """

    N = len(x)
    n = np.arange(N)
    k = n.reshape((N, 1))
    e = np.exp(-2j * np.pi * k * n / N)
    
    X = np.dot(e, x)
    
    return X

_, signal = wavfile.read('s1_vikash16000.wav')
# Define the sampling frequencies to analyze
fs = [16000]


# Calculate DFT and plot magnitude spectrum for each sampling frequency
for i in fs:
    # Resample the signal
    new_rate = i
    number_of_samples = round(len(signal) * float(new_rate) / _)
    resampled_signal = sps.resample(signal, number_of_samples)

    # Number of samples in the resampled signal
    N = resampled_signal.shape[0]

    # Time vector
    t = np.arange(N) / new_rate

    # Frequency vector
    freq_range = np.linspace(0, new_rate/2, N//2)
  
    # Calculate DFT
    dft_signal = DFT(resampled_signal)
    # Plot magnitude spectrum
    plt.figure()
    plt.plot(freq_range, np.abs(dft_signal[:N//2]))
    plt.xlabel('Frequency (Hz)')
    plt.ylabel('Magnitude')
    plt.title('Magnitude Spectrum (fs = {} Hz)'.format(new_rate))
    plt.show()

#filtering of the signals!
# Load the recorded signal from a file
recorded_signal, fs = librosa.load('s1_vikash16000.wav', sr=None)

# Define the filter coefficients
filter_order = 1000
filter_cutoff = 4000 # Hz
filter_coeffs = sps.firwin(filter_order, filter_cutoff, fs=fs)

# Apply the filter to the recorded signal
filtered_signal = sps.convolve(recorded_signal, filter_coeffs, mode='same')

# Plot the recorded and filtered signals
time = np.arange(len(recorded_signal)) / fs

fig, ax = plt.subplots(2, 1, sharex=True, figsize=(8, 6))
ax[0].plot(time, recorded_signal)
ax[0].set_ylabel('Amplitude')
ax[0].set_title('Recorded signal')
ax[1].plot(time, filtered_signal)
ax[1].set_xlabel('Time (s)')
ax[1].set_ylabel('Amplitude')
ax[1].set_title('Filtered signal')
plt.show()

#new new new i guess the correct one!
import numpy as np
from scipy.io import wavfile
import matplotlib.pyplot as plt
import scipy.signal as sps


import librosa

from pydub import AudioSegment
def DFT(x):
    """
    Function to calculate the 
    discrete Fourier Transform 
    of a 1D real-valued signal x
    """

    N = len(x)
    n = np.arange(N)
    k = n.reshape((N, 1))
    e = np.exp(-2j * np.pi * k * n / N)
    
    X = np.dot(e, x)
    
    return X

_, signal = wavfile.read('s2_vikash16000.wav')
# Define the sampling frequencies to analyze
fs = [16000]


# Calculate DFT and plot magnitude spectrum for each sampling frequency
for i in fs:
    # Resample the signal
    new_rate = i
    number_of_samples = round(len(signal) * float(new_rate) / _)
    from numpy.fft import fft as dFT 
    resampled_signal = sps.resample(signal, number_of_samples)

    # Number of samples in the resampled signal
    N = resampled_signal.shape[0]

    # Time vector
    t = np.arange(N) / new_rate

    # Frequency vector
    freq_range = np.linspace(0, new_rate/2, N//2)
  
    # Calculate DFT
    dft_signal = dFT(resampled_signal)
    # Plot magnitude spectrum
    plt.figure()
    plt.plot(freq_range, np.abs(dft_signal[:N//2]))
    plt.xlabel('Frequency (Hz)')
    plt.ylabel('Magnitude')
    plt.title('Magnitude Spectrum (fs = {} Hz)'.format(new_rate))
    plt.show()

#filtering of the signals!
# Load the recorded signal from a file
recorded_signal, fs = librosa.load('s2_vikash16000.wav', sr=None)

# Define the filter coefficients
filter_order = 1000
filter_cutoff = 4000 # Hz
filter_coeffs = sps.firwin(filter_order, filter_cutoff, fs=fs)

# Apply the filter to the recorded signal
filtered_signal = sps.convolve(recorded_signal, filter_coeffs, mode='same')

# Plot the recorded and filtered signals
time = np.arange(len(recorded_signal)) / fs

fig, ax = plt.subplots(2, 1, sharex=True, figsize=(8, 6))
ax[0].plot(time, recorded_signal)
ax[0].set_ylabel('Amplitude')
ax[0].set_title('Recorded signal')
ax[1].plot(time, filtered_signal)
ax[1].set_xlabel('Time (s)')
ax[1].set_ylabel('Amplitude')
ax[1].set_title('Filtered signal')
plt.show()

#new new new i guess the correct one!
import numpy as np
from scipy.io import wavfile
import matplotlib.pyplot as plt
import scipy.signal as sps


import librosa

from pydub import AudioSegment
def DFT(x):
    """
    Function to calculate the 
    discrete Fourier Transform 
    of a 1D real-valued signal x
    """

    N = len(x)
    n = np.arange(N)
    k = n.reshape((N, 1))
    e = np.exp(-2j * np.pi * k * n / N)
    
    X = np.dot(e, x)
    
    return X

_, signal = wavfile.read('s3_vikash16000.wav')
# Define the sampling frequencies to analyze
fs = [16000]


# Calculate DFT and plot magnitude spectrum for each sampling frequency
for i in fs:
    # Resample the signal
    new_rate = i
    number_of_samples = round(len(signal) * float(new_rate) / _)
    resampled_signal = sps.resample(signal, number_of_samples)

    # Number of samples in the resampled signal
    N = resampled_signal.shape[0]
    from numpy.fft import fft as dFT
    # Time vector
    t = np.arange(N) / new_rate

    # Frequency vector
    freq_range = np.linspace(0, new_rate/2, N//2)
  
    # Calculate DFT
    dft_signal = dFT(resampled_signal)
    # Plot magnitude spectrum
    plt.figure()
    plt.plot(freq_range, np.abs(dft_signal[:N//2]))
    plt.xlabel('Frequency (Hz)')
    plt.ylabel('Magnitude')
    plt.title('Magnitude Spectrum (fs = {} Hz)'.format(new_rate))
    plt.show()

#filtering of the signals!
# Load the recorded signal from a file
recorded_signal, fs = librosa.load('s3_vikash16000.wav', sr=None)

# Define the filter coefficients
filter_order = 1000
filter_cutoff = 2000 # Hz
filter_coeffs = sps.firwin(filter_order, filter_cutoff, fs=fs)

# Apply the filter to the recorded signal
filtered_signal = sps.convolve(recorded_signal, filter_coeffs, mode='same')

# Plot the recorded and filtered signals
time = np.arange(len(recorded_signal)) / fs

fig, ax = plt.subplots(2, 1, sharex=True, figsize=(8, 6))
ax[0].plot(time, recorded_signal)
ax[0].set_ylabel('Amplitude')
ax[0].set_title('Recorded signal')
ax[1].plot(time, filtered_signal)
ax[1].set_xlabel('Time (s)')
ax[1].set_ylabel('Amplitude')
ax[1].set_title('Filtered signal')
plt.show()

#new new new i guess the correct one!
import numpy as np
from scipy.io import wavfile
import matplotlib.pyplot as plt
import scipy.signal as sps


import librosa

from pydub import AudioSegment
def DFT(x):
    """
    Function to calculate the 
    discrete Fourier Transform 
    of a 1D real-valued signal x
    """

    N = len(x)
    n = np.arange(N)
    k = n.reshape((N, 1))
    e = np.exp(-2j * np.pi * k * n / N)
    
    X = np.dot(e, x)
    
    return X

_, signal = wavfile.read('s4_vikash16000.wav')
# Define the sampling frequencies to analyze
fs = [16000]


# Calculate DFT and plot magnitude spectrum for each sampling frequency
for i in fs:
    # Resample the signal
    new_rate = i
    number_of_samples = round(len(signal) * float(new_rate) / _)
    resampled_signal = sps.resample(signal, number_of_samples)

    # Number of samples in the resampled signal
    N = resampled_signal.shape[0]

    # Time vector
    t = np.arange(N) / new_rate

    # Frequency vector
    freq_range = np.linspace(0, new_rate/2, N//2)
  
    # Calculate DFT
    dft_signal = DFT(resampled_signal)
    # Plot magnitude spectrum
    plt.figure()
    plt.plot(freq_range, np.abs(dft_signal[:N//2]))
    plt.xlabel('Frequency (Hz)')
    plt.ylabel('Magnitude')
    plt.title('Magnitude Spectrum (fs = {} Hz)'.format(new_rate))
    plt.show()

#filtering of the signals!
# Load the recorded signal from a file
recorded_signal, fs = librosa.load('s4_vikash16000.wav', sr=None)

# Define the filter coefficients
filter_order = 1000
filter_cutoff = 4000 # Hz
filter_coeffs = sps.firwin(filter_order, filter_cutoff, fs=fs)

# Apply the filter to the recorded signal
filtered_signal = sps.convolve(recorded_signal, filter_coeffs, mode='same')

# Plot the recorded and filtered signals
time = np.arange(len(recorded_signal)) / fs

fig, ax = plt.subplots(2, 1, sharex=True, figsize=(8, 6))
ax[0].plot(time, recorded_signal)
ax[0].set_ylabel('Amplitude')
ax[0].set_title('Recorded signal')
ax[1].plot(time, filtered_signal)
ax[1].set_xlabel('Time (s)')
ax[1].set_ylabel('Amplitude')
ax[1].set_title('Filtered signal')
plt.show()

#new new new i guess the correct one!
import numpy as np
from scipy.io import wavfile
import matplotlib.pyplot as plt
import scipy.signal as sps


import librosa

from pydub import AudioSegment
def DFT(x):
    """
    Function to calculate the 
    discrete Fourier Transform 
    of a 1D real-valued signal x
    """

    N = len(x)
    n = np.arange(N)
    k = n.reshape((N, 1))
    e = np.exp(-2j * np.pi * k * n / N)
    
    X = np.dot(e, x)
    
    return X

_, signal = wavfile.read('s1_rohan500.wav')
# Define the sampling frequencies to analyze
fs = [500]


# Calculate DFT and plot magnitude spectrum for each sampling frequency
for i in fs:
    # Resample the signal
    new_rate = i
    number_of_samples = round(len(signal) * float(new_rate) / _)
    resampled_signal = sps.resample(signal, number_of_samples)

    # Number of samples in the resampled signal
    N = resampled_signal.shape[0]

    # Time vector
    t = np.arange(N) / new_rate

    # Frequency vector
    freq_range = np.linspace(0, new_rate/2, N//2)
  
    # Calculate DFT
    dft_signal = DFT(resampled_signal)
    # Plot magnitude spectrum
    plt.figure()
    plt.plot(freq_range, np.abs(dft_signal[:N//2]))
    plt.xlabel('Frequency (Hz)')
    plt.ylabel('Magnitude')
    plt.title('Magnitude Spectrum (fs = {} Hz)'.format(new_rate))
    plt.show()

#filtering of the signals!
# Load the recorded signal from a file
recorded_signal, fs = librosa.load('s1_rohan500.wav', sr=None)

# Define the filter coefficients
filter_order = 100
filter_cutoff = 160 # Hz
filter_coeffs = sps.firwin(filter_order, filter_cutoff, fs=fs)

# Apply the filter to the recorded signal
filtered_signal = sps.convolve(recorded_signal, filter_coeffs, mode='same')

# Plot the recorded and filtered signals
time = np.arange(len(recorded_signal)) / fs

fig, ax = plt.subplots(2, 1, sharex=True, figsize=(8, 6))
ax[0].plot(time, recorded_signal)
ax[0].set_ylabel('Amplitude')
ax[0].set_title('Recorded signal')
ax[1].plot(time, filtered_signal)
ax[1].set_xlabel('Time (s)')
ax[1].set_ylabel('Amplitude')
ax[1].set_title('Filtered signal')
plt.show()

#new new new i guess the correct one!
import numpy as np
from scipy.io import wavfile
import matplotlib.pyplot as plt
import scipy.signal as sps


import librosa

from pydub import AudioSegment
def DFT(x):
    """
    Function to calculate the 
    discrete Fourier Transform 
    of a 1D real-valued signal x
    """

    N = len(x)
    n = np.arange(N)
    k = n.reshape((N, 1))
    e = np.exp(-2j * np.pi * k * n / N)
    
    X = np.dot(e, x)
    
    return X

_, signal = wavfile.read('s2_rohan500.wav')
# Define the sampling frequencies to analyze
fs = [500]


# Calculate DFT and plot magnitude spectrum for each sampling frequency
for i in fs:
    # Resample the signal
    new_rate = i
    number_of_samples = round(len(signal) * float(new_rate) / _)
    resampled_signal = sps.resample(signal, number_of_samples)

    # Number of samples in the resampled signal
    N = resampled_signal.shape[0]

    # Time vector
    t = np.arange(N) / new_rate

    # Frequency vector
    freq_range = np.linspace(0, new_rate/2, N//2)
  
    # Calculate DFT
    dft_signal = DFT(resampled_signal)
    # Plot magnitude spectrum
    plt.figure()
    plt.plot(freq_range, np.abs(dft_signal[:N//2]))
    plt.xlabel('Frequency (Hz)')
    plt.ylabel('Magnitude')
    plt.title('Magnitude Spectrum (fs = {} Hz)'.format(new_rate))
    plt.show()

#filtering of the signals!
# Load the recorded signal from a file
recorded_signal, fs = librosa.load('s2_rohan500.wav', sr=None)

# Define the filter coefficients
filter_order = 100
filter_cutoff = 160 # Hz
filter_coeffs = sps.firwin(filter_order, filter_cutoff, fs=fs)

# Apply the filter to the recorded signal
filtered_signal = sps.convolve(recorded_signal, filter_coeffs, mode='same')

# Plot the recorded and filtered signals
time = np.arange(len(recorded_signal)) / fs

fig, ax = plt.subplots(2, 1, sharex=True, figsize=(8, 6))
ax[0].plot(time, recorded_signal)
ax[0].set_ylabel('Amplitude')
ax[0].set_title('Recorded signal')
ax[1].plot(time, filtered_signal)
ax[1].set_xlabel('Time (s)')
ax[1].set_ylabel('Amplitude')
ax[1].set_title('Filtered signal')
plt.show()

#new new new i guess the correct one!
import numpy as np
from scipy.io import wavfile
import matplotlib.pyplot as plt
import scipy.signal as sps


import librosa

from pydub import AudioSegment
def DFT(x):
    """
    Function to calculate the 
    discrete Fourier Transform 
    of a 1D real-valued signal x
    """

    N = len(x)
    n = np.arange(N)
    k = n.reshape((N, 1))
    e = np.exp(-2j * np.pi * k * n / N)
    
    X = np.dot(e, x)
    
    return X

_, signal = wavfile.read('s3_rohan500.wav')
# Define the sampling frequencies to analyze
fs = [500]


# Calculate DFT and plot magnitude spectrum for each sampling frequency
for i in fs:
    # Resample the signal
    new_rate = i
    number_of_samples = round(len(signal) * float(new_rate) / _)
    resampled_signal = sps.resample(signal, number_of_samples)

    # Number of samples in the resampled signal
    N = resampled_signal.shape[0]

    # Time vector
    t = np.arange(N) / new_rate

    # Frequency vector
    freq_range = np.linspace(0, new_rate/2, N//2)
  
    # Calculate DFT
    dft_signal = DFT(resampled_signal)
    # Plot magnitude spectrum
    plt.figure()
    plt.plot(freq_range, np.abs(dft_signal[:N//2]))
    plt.xlabel('Frequency (Hz)')
    plt.ylabel('Magnitude')
    plt.title('Magnitude Spectrum (fs = {} Hz)'.format(new_rate))
    plt.show()

#filtering of the signals!
# Load the recorded signal from a file
recorded_signal, fs = librosa.load('s3_rohan500.wav', sr=None)

# Define the filter coefficients
filter_order = 100
filter_cutoff = 160 # Hz
filter_coeffs = sps.firwin(filter_order, filter_cutoff, fs=fs)

# Apply the filter to the recorded signal
filtered_signal = sps.convolve(recorded_signal, filter_coeffs, mode='same')

# Plot the recorded and filtered signals
time = np.arange(len(recorded_signal)) / fs

fig, ax = plt.subplots(2, 1, sharex=True, figsize=(8, 6))
ax[0].plot(time, recorded_signal)
ax[0].set_ylabel('Amplitude')
ax[0].set_title('Recorded signal')
ax[1].plot(time, filtered_signal)
ax[1].set_xlabel('Time (s)')
ax[1].set_ylabel('Amplitude')
ax[1].set_title('Filtered signal')
plt.show()

#new new new i guess the correct one!
import numpy as np
from scipy.io import wavfile
import matplotlib.pyplot as plt
import scipy.signal as sps


import librosa

from pydub import AudioSegment
def DFT(x):
    """
    Function to calculate the 
    discrete Fourier Transform 
    of a 1D real-valued signal x
    """

    N = len(x)
    n = np.arange(N)
    k = n.reshape((N, 1))
    e = np.exp(-2j * np.pi * k * n / N)
    
    X = np.dot(e, x)
    
    return X

_, signal = wavfile.read('s4_rohan500.wav')
# Define the sampling frequencies to analyze
fs = [500]


# Calculate DFT and plot magnitude spectrum for each sampling frequency
for i in fs:
    # Resample the signal
    new_rate = i
    number_of_samples = round(len(signal) * float(new_rate) / _)
    resampled_signal = sps.resample(signal, number_of_samples)

    # Number of samples in the resampled signal
    N = resampled_signal.shape[0]

    # Time vector
    t = np.arange(N) / new_rate

    # Frequency vector
    freq_range = np.linspace(0, new_rate/2, N//2)
  
    # Calculate DFT
    dft_signal = DFT(resampled_signal)
    # Plot magnitude spectrum
    plt.figure()
    plt.plot(freq_range, np.abs(dft_signal[:N//2]))
    plt.xlabel('Frequency (Hz)')
    plt.ylabel('Magnitude')
    plt.title('Magnitude Spectrum (fs = {} Hz)'.format(new_rate))
    plt.show()

#filtering of the signals!
# Load the recorded signal from a file
recorded_signal, fs = librosa.load('s4_rohan500.wav', sr=None)

# Define the filter coefficients
filter_order = 100
filter_cutoff = 160 # Hz
filter_coeffs = sps.firwin(filter_order, filter_cutoff, fs=fs)

# Apply the filter to the recorded signal
filtered_signal = sps.convolve(recorded_signal, filter_coeffs, mode='same')

# Plot the recorded and filtered signals
time = np.arange(len(recorded_signal)) / fs

fig, ax = plt.subplots(2, 1, sharex=True, figsize=(8, 6))
ax[0].plot(time, recorded_signal)
ax[0].set_ylabel('Amplitude')
ax[0].set_title('Recorded signal')
ax[1].plot(time, filtered_signal)
ax[1].set_xlabel('Time (s)')
ax[1].set_ylabel('Amplitude')
ax[1].set_title('Filtered signal')
plt.show()

import numpy as np
from scipy.io import wavfile
import matplotlib.pyplot as plt
import scipy.signal as sps


import librosa

from pydub import AudioSegment
def DFT(x):
    """
    Function to calculate the 
    discrete Fourier Transform 
    of a 1D real-valued signal x
    """

    N = len(x)
    n = np.arange(N)
    k = n.reshape((N, 1))
    e = np.exp(-2j * np.pi * k * n / N)
    
    X = np.dot(e, x)
    
    return X

_, signal = wavfile.read('s1_rohan2000.wav')
# Define the sampling frequencies to analyze
fs = [2000]


# Calculate DFT and plot magnitude spectrum for each sampling frequency
for i in fs:
    # Resample the signal
    new_rate = i
    number_of_samples = round(len(signal) * float(new_rate) / _)
    resampled_signal = sps.resample(signal, number_of_samples)

    # Number of samples in the resampled signal
    N = resampled_signal.shape[0]

    # Time vector
    t = np.arange(N) / new_rate

    # Frequency vector
    freq_range = np.linspace(0, new_rate/2, N//2)
  
    # Calculate DFT
    dft_signal = DFT(resampled_signal)
    # Plot magnitude spectrum
    plt.figure()
    plt.plot(freq_range, np.abs(dft_signal[:N//2]))
    plt.xlabel('Frequency (Hz)')
    plt.ylabel('Magnitude')
    plt.title('Magnitude Spectrum (fs = {} Hz)'.format(new_rate))
    plt.show()

#filtering of the signals!
# Load the recorded signal from a file
recorded_signal, fs = librosa.load('s1_rohan2000.wav', sr=None)

# Define the filter coefficients
filter_order = 100
filter_cutoff = 150 # Hz
filter_coeffs = sps.firwin(filter_order, filter_cutoff, fs=fs)

# Apply the filter to the recorded signal
filtered_signal = sps.convolve(recorded_signal, filter_coeffs, mode='same')

# Plot the recorded and filtered signals
time = np.arange(len(recorded_signal)) / fs

fig, ax = plt.subplots(2, 1, sharex=True, figsize=(8, 6))
ax[0].plot(time, recorded_signal)
ax[0].set_ylabel('Amplitude')
ax[0].set_title('Recorded signal')
ax[1].plot(time, filtered_signal)
ax[1].set_xlabel('Time (s)')
ax[1].set_ylabel('Amplitude')
ax[1].set_title('Filtered signal')
plt.show()

import numpy as np
from scipy.io import wavfile
import matplotlib.pyplot as plt
import scipy.signal as sps


import librosa

from pydub import AudioSegment
def DFT(x):
    """
    Function to calculate the 
    discrete Fourier Transform 
    of a 1D real-valued signal x
    """

    N = len(x)
    n = np.arange(N)
    k = n.reshape((N, 1))
    e = np.exp(-2j * np.pi * k * n / N)
    
    X = np.dot(e, x)
    
    return X

_, signal = wavfile.read('s2_rohan2000.wav')
# Define the sampling frequencies to analyze
fs = [2000]


# Calculate DFT and plot magnitude spectrum for each sampling frequency
for i in fs:
    # Resample the signal
    new_rate = i
    number_of_samples = round(len(signal) * float(new_rate) / _)
    resampled_signal = sps.resample(signal, number_of_samples)

    # Number of samples in the resampled signal
    N = resampled_signal.shape[0]

    # Time vector
    t = np.arange(N) / new_rate

    # Frequency vector
    freq_range = np.linspace(0, new_rate/2, N//2)
  
    # Calculate DFT
    dft_signal = DFT(resampled_signal)
    # Plot magnitude spectrum
    plt.figure()
    plt.plot(freq_range, np.abs(dft_signal[:N//2]))
    plt.xlabel('Frequency (Hz)')
    plt.ylabel('Magnitude')
    plt.title('Magnitude Spectrum (fs = {} Hz)'.format(new_rate))
    plt.show()

#filtering of the signals!
# Load the recorded signal from a file
recorded_signal, fs = librosa.load('s2_rohan2000.wav', sr=None)

# Define the filter coefficients
filter_order = 100
filter_cutoff = 150 # Hz
filter_coeffs = sps.firwin(filter_order, filter_cutoff, fs=fs)

# Apply the filter to the recorded signal
filtered_signal = sps.convolve(recorded_signal, filter_coeffs, mode='same')

# Plot the recorded and filtered signals
time = np.arange(len(recorded_signal)) / fs

fig, ax = plt.subplots(2, 1, sharex=True, figsize=(8, 6))
ax[0].plot(time, recorded_signal)
ax[0].set_ylabel('Amplitude')
ax[0].set_title('Recorded signal')
ax[1].plot(time, filtered_signal)
ax[1].set_xlabel('Time (s)')
ax[1].set_ylabel('Amplitude')
ax[1].set_title('Filtered signal')
plt.show()

#new new new i guess the correct one!
import numpy as np
from scipy.io import wavfile
import matplotlib.pyplot as plt
import scipy.signal as sps


import librosa

from pydub import AudioSegment
def DFT(x):
    """
    Function to calculate the 
    discrete Fourier Transform 
    of a 1D real-valued signal x
    """

    N = len(x)
    n = np.arange(N)
    k = n.reshape((N, 1))
    e = np.exp(-2j * np.pi * k * n / N)
    
    X = np.dot(e, x)
    
    return X

_, signal = wavfile.read('s3_rohan2000.wav')
# Define the sampling frequencies to analyze
fs = [2000]


# Calculate DFT and plot magnitude spectrum for each sampling frequency
for i in fs:
    # Resample the signal
    new_rate = i
    number_of_samples = round(len(signal) * float(new_rate) / _)
    resampled_signal = sps.resample(signal, number_of_samples)

    # Number of samples in the resampled signal
    N = resampled_signal.shape[0]

    # Time vector
    t = np.arange(N) / new_rate

    # Frequency vector
    freq_range = np.linspace(0, new_rate/2, N//2)
  
    # Calculate DFT
    dft_signal = DFT(resampled_signal)
    # Plot magnitude spectrum
    plt.figure()
    plt.plot(freq_range, np.abs(dft_signal[:N//2]))
    plt.xlabel('Frequency (Hz)')
    plt.ylabel('Magnitude')
    plt.title('Magnitude Spectrum (fs = {} Hz)'.format(new_rate))
    plt.show()

#filtering of the signals!
# Load the recorded signal from a file
recorded_signal, fs = librosa.load('s3_rohan2000.wav', sr=None)

# Define the filter coefficients
filter_order = 100
filter_cutoff = 180 # Hz
filter_coeffs = sps.firwin(filter_order, filter_cutoff, fs=fs)

# Apply the filter to the recorded signal
filtered_signal = sps.convolve(recorded_signal, filter_coeffs, mode='same')

# Plot the recorded and filtered signals
time = np.arange(len(recorded_signal)) / fs

fig, ax = plt.subplots(2, 1, sharex=True, figsize=(8, 6))
ax[0].plot(time, recorded_signal)
ax[0].set_ylabel('Amplitude')
ax[0].set_title('Recorded signal')
ax[1].plot(time, filtered_signal)
ax[1].set_xlabel('Time (s)')
ax[1].set_ylabel('Amplitude')
ax[1].set_title('Filtered signal')
plt.show()

#new new new i guess the correct one!
import numpy as np
from scipy.io import wavfile
import matplotlib.pyplot as plt
import scipy.signal as sps


import librosa

from pydub import AudioSegment
def DFT(x):
    """
    Function to calculate the 
    discrete Fourier Transform 
    of a 1D real-valued signal x
    """

    N = len(x)
    n = np.arange(N)
    k = n.reshape((N, 1))
    e = np.exp(-2j * np.pi * k * n / N)
    
    X = np.dot(e, x)
    
    return X

_, signal = wavfile.read('s4_rohan2000.wav')
# Define the sampling frequencies to analyze
fs = [2000]


# Calculate DFT and plot magnitude spectrum for each sampling frequency
for i in fs:
    # Resample the signal
    new_rate = i
    number_of_samples = round(len(signal) * float(new_rate) / _)
    resampled_signal = sps.resample(signal, number_of_samples)

    # Number of samples in the resampled signal
    N = resampled_signal.shape[0]

    # Time vector
    t = np.arange(N) / new_rate

    # Frequency vector
    freq_range = np.linspace(0, new_rate/2, N//2)
  
    # Calculate DFT
    dft_signal = DFT(resampled_signal)
    # Plot magnitude spectrum
    plt.figure()
    plt.plot(freq_range, np.abs(dft_signal[:N//2]))
    plt.xlabel('Frequency (Hz)')
    plt.ylabel('Magnitude')
    plt.title('Magnitude Spectrum (fs = {} Hz)'.format(new_rate))
    plt.show()

#filtering of the signals!
# Load the recorded signal from a file
recorded_signal, fs = librosa.load('s4_rohan2000.wav', sr=None)

# Define the filter coefficients
filter_order = 100
filter_cutoff = 200 # Hz
filter_coeffs = sps.firwin(filter_order, filter_cutoff, fs=fs)

# Apply the filter to the recorded signal
filtered_signal = sps.convolve(recorded_signal, filter_coeffs, mode='same')

# Plot the recorded and filtered signals
time = np.arange(len(recorded_signal)) / fs

fig, ax = plt.subplots(2, 1, sharex=True, figsize=(8, 6))
ax[0].plot(time, recorded_signal)
ax[0].set_ylabel('Amplitude')
ax[0].set_title('Recorded signal')
ax[1].plot(time, filtered_signal)
ax[1].set_xlabel('Time (s)')
ax[1].set_ylabel('Amplitude')
ax[1].set_title('Filtered signal')
plt.show()

#new new new i guess the correct one!
import numpy as np
from scipy.io import wavfile
import matplotlib.pyplot as plt
import scipy.signal as sps


import librosa

from pydub import AudioSegment
def DFT(x):
    """
    Function to calculate the 
    discrete Fourier Transform 
    of a 1D real-valued signal x
    """

    N = len(x)
    n = np.arange(N)
    k = n.reshape((N, 1))
    e = np.exp(-2j * np.pi * k * n / N)
    
    X = np.dot(e, x)
    
    return X

_, signal = wavfile.read('s1_rohan16000.wav')
# Define the sampling frequencies to analyze
fs = [16000]


# Calculate DFT and plot magnitude spectrum for each sampling frequency
for i in fs:
    # Resample the signal
    new_rate = i
    number_of_samples = round(len(signal) * float(new_rate) / _)
    resampled_signal = sps.resample(signal, number_of_samples)

    # Number of samples in the resampled signal
    N = resampled_signal.shape[0]

    # Time vector
    t = np.arange(N) / new_rate

    # Frequency vector
    freq_range = np.linspace(0, new_rate/2, N//2)
  
    # Calculate DFT
    dft_signal = DFT(resampled_signal)
    # Plot magnitude spectrum
    plt.figure()
    plt.plot(freq_range, np.abs(dft_signal[:N//2]))
    plt.xlabel('Frequency (Hz)')
    plt.ylabel('Magnitude')
    plt.title('Magnitude Spectrum (fs = {} Hz)'.format(new_rate))
    plt.show()

#filtering of the signals!
# Load the recorded signal from a file
recorded_signal, fs = librosa.load('s1_rohan2000.wav', sr=None)

# Define the filter coefficients
filter_order = 1000
filter_cutoff = 4000 # Hz
filter_coeffs = sps.firwin(filter_order, filter_cutoff, fs=fs)

# Apply the filter to the recorded signal
filtered_signal = sps.convolve(recorded_signal, filter_coeffs, mode='same')

# Plot the recorded and filtered signals
time = np.arange(len(recorded_signal)) / fs

fig, ax = plt.subplots(2, 1, sharex=True, figsize=(8, 6))
ax[0].plot(time, recorded_signal)
ax[0].set_ylabel('Amplitude')
ax[0].set_title('Recorded signal')
ax[1].plot(time, filtered_signal)
ax[1].set_xlabel('Time (s)')
ax[1].set_ylabel('Amplitude')
ax[1].set_title('Filtered signal')
plt.show()

#new new new i guess the correct one!
import numpy as np
from scipy.io import wavfile
import matplotlib.pyplot as plt
import scipy.signal as sps


import librosa

from pydub import AudioSegment
def DFT(x):
    """
    Function to calculate the 
    discrete Fourier Transform 
    of a 1D real-valued signal x
    """

    N = len(x)
    n = np.arange(N)
    k = n.reshape((N, 1))
    e = np.exp(-2j * np.pi * k * n / N)
    
    X = np.dot(e, x)
    
    return X

_, signal = wavfile.read('s2_rohan16000.wav')
# Define the sampling frequencies to analyze
fs = [16000]


# Calculate DFT and plot magnitude spectrum for each sampling frequency
for i in fs:
    # Resample the signal
    new_rate = i
    number_of_samples = round(len(signal) * float(new_rate) / _)
    resampled_signal = sps.resample(signal, number_of_samples)

    # Number of samples in the resampled signal
    N = resampled_signal.shape[0]

    # Time vector
    t = np.arange(N) / new_rate

    # Frequency vector
    freq_range = np.linspace(0, new_rate/2, N//2)
  
    # Calculate DFT
    dft_signal = DFT(resampled_signal)
    # Plot magnitude spectrum
    plt.figure()
    plt.plot(freq_range, np.abs(dft_signal[:N//2]))
    plt.xlabel('Frequency (Hz)')
    plt.ylabel('Magnitude')
    plt.title('Magnitude Spectrum (fs = {} Hz)'.format(new_rate))
    plt.show()

#filtering of the signals!
# Load the recorded signal from a file
recorded_signal, fs = librosa.load('s2_rohan2000.wav', sr=None)

# Define the filter coefficients
filter_order = 1000
filter_cutoff = 4000 # Hz
filter_coeffs = sps.firwin(filter_order, filter_cutoff, fs=fs)

# Apply the filter to the recorded signal
filtered_signal = sps.convolve(recorded_signal, filter_coeffs, mode='same')

# Plot the recorded and filtered signals
time = np.arange(len(recorded_signal)) / fs

fig, ax = plt.subplots(2, 1, sharex=True, figsize=(8, 6))
ax[0].plot(time, recorded_signal)
ax[0].set_ylabel('Amplitude')
ax[0].set_title('Recorded signal')
ax[1].plot(time, filtered_signal)
ax[1].set_xlabel('Time (s)')
ax[1].set_ylabel('Amplitude')
ax[1].set_title('Filtered signal')
plt.show()

#new new new i guess the correct one!
import numpy as np
from scipy.io import wavfile
import matplotlib.pyplot as plt
import scipy.signal as sps


import librosa

from pydub import AudioSegment
def DFT(x):
    """
    Function to calculate the 
    discrete Fourier Transform 
    of a 1D real-valued signal x
    """

    N = len(x)
    n = np.arange(N)
    k = n.reshape((N, 1))
    e = np.exp(-2j * np.pi * k * n / N)
    
    X = np.dot(e, x)
    
    return X

_, signal = wavfile.read('s2_rohan16000.wav')
# Define the sampling frequencies to analyze
fs = [16000]


# Calculate DFT and plot magnitude spectrum for each sampling frequency
for i in fs:
    # Resample the signal
    new_rate = i
    number_of_samples = round(len(signal) * float(new_rate) / _)
    resampled_signal = sps.resample(signal, number_of_samples)

    # Number of samples in the resampled signal
    N = resampled_signal.shape[0]

    # Time vector
    t = np.arange(N) / new_rate

    # Frequency vector
    freq_range = np.linspace(0, new_rate/2, N//2)
  
    # Calculate DFT
    dft_signal = DFT(resampled_signal)
    # Plot magnitude spectrum
    plt.figure()
    plt.plot(freq_range, np.abs(dft_signal[:N//2]))
    plt.xlabel('Frequency (Hz)')
    plt.ylabel('Magnitude')
    plt.title('Magnitude Spectrum (fs = {} Hz)'.format(new_rate))
    plt.show()

#filtering of the signals!
# Load the recorded signal from a file
recorded_signal, fs = librosa.load('s2_rohan2000.wav', sr=None)

# Define the filter coefficients
filter_order = 1000
filter_cutoff = 4000 # Hz
filter_coeffs = sps.firwin(filter_order, filter_cutoff, fs=fs)

# Apply the filter to the recorded signal
filtered_signal = sps.convolve(recorded_signal, filter_coeffs, mode='same')

# Plot the recorded and filtered signals
time = np.arange(len(recorded_signal)) / fs

fig, ax = plt.subplots(2, 1, sharex=True, figsize=(8, 6))
ax[0].plot(time, recorded_signal)
ax[0].set_ylabel('Amplitude')
ax[0].set_title('Recorded signal')
ax[1].plot(time, filtered_signal)
ax[1].set_xlabel('Time (s)')
ax[1].set_ylabel('Amplitude')
ax[1].set_title('Filtered signal')
plt.show()

#new new new i guess the correct one!
import numpy as np
from scipy.io import wavfile
import matplotlib.pyplot as plt
import scipy.signal as sps


import librosa

from pydub import AudioSegment
def DFT(x):
    """
    Function to calculate the 
    discrete Fourier Transform 
    of a 1D real-valued signal x
    """

    N = len(x)
    n = np.arange(N)
    k = n.reshape((N, 1))
    e = np.exp(-2j * np.pi * k * n / N)
    
    X = np.dot(e, x)
    
    return X

_, signal = wavfile.read('s3_rohan16000.wav')
# Define the sampling frequencies to analyze
fs = [16000]


# Calculate DFT and plot magnitude spectrum for each sampling frequency
for i in fs:
    # Resample the signal
    new_rate = i
    from numpy.fft import fft as dFT
    number_of_samples = round(len(signal) * float(new_rate) / _)
    resampled_signal = sps.resample(signal, number_of_samples)

    # Number of samples in the resampled signal
    N = resampled_signal.shape[0]

    # Time vector
    t = np.arange(N) / new_rate

    # Frequency vector
    freq_range = np.linspace(0, new_rate/2, N//2)
  
    # Calculate DFT
    dft_signal = dFT(resampled_signal)
    # Plot magnitude spectrum
    plt.figure()
    plt.plot(freq_range, np.abs(dft_signal[:N//2]))
    plt.xlabel('Frequency (Hz)')
    plt.ylabel('Magnitude')
    plt.title('Magnitude Spectrum (fs = {} Hz)'.format(new_rate))
    plt.show()

#filtering of the signals!
# Load the recorded signal from a file
recorded_signal, fs = librosa.load('s3_rohan2000.wav', sr=None)

# Define the filter coefficients
filter_order = 1000
filter_cutoff = 600 # Hz
filter_coeffs = sps.firwin(filter_order, filter_cutoff, fs=fs)

# Apply the filter to the recorded signal
filtered_signal = sps.convolve(recorded_signal, filter_coeffs, mode='same')

# Plot the recorded and filtered signals
time = np.arange(len(recorded_signal)) / fs

fig, ax = plt.subplots(2, 1, sharex=True, figsize=(8, 6))
ax[0].plot(time, recorded_signal)
ax[0].set_ylabel('Amplitude')
ax[0].set_title('Recorded signal')
ax[1].plot(time, filtered_signal)
ax[1].set_xlabel('Time (s)')
ax[1].set_ylabel('Amplitude')
ax[1].set_title('Filtered signal')
plt.show()

#new new new i guess the correct one!
import numpy as np
from scipy.io import wavfile
import matplotlib.pyplot as plt
import scipy.signal as sps


import librosa

from pydub import AudioSegment
def DFT(x):
    """
    Function to calculate the 
    discrete Fourier Transform 
    of a 1D real-valued signal x
    """

    N = len(x)
    n = np.arange(N)
    k = n.reshape((N, 1))
    e = np.exp(-2j * np.pi * k * n / N)
    
    X = np.dot(e, x)
    
    return X

_, signal = wavfile.read('s4_rohan16000.wav')
# Define the sampling frequencies to analyze
fs = [16000]


# Calculate DFT and plot magnitude spectrum for each sampling frequency
for i in fs:
    # Resample the signal
    new_rate = i
    number_of_samples = round(len(signal) * float(new_rate) / _)
    resampled_signal = sps.resample(signal, number_of_samples)

    # Number of samples in the resampled signal
    N = resampled_signal.shape[0]

    # Time vector
    t = np.arange(N) / new_rate

    # Frequency vector
    freq_range = np.linspace(0, new_rate/2, N//2)
  
    # Calculate DFT
    dft_signal = DFT(resampled_signal)
    # Plot magnitude spectrum
    plt.figure()
    plt.plot(freq_range, np.abs(dft_signal[:N//2]))
    plt.xlabel('Frequency (Hz)')
    plt.ylabel('Magnitude')
    plt.title('Magnitude Spectrum (fs = {} Hz)'.format(new_rate))
    plt.show()

#filtering of the signals!
# Load the recorded signal from a file
recorded_signal, fs = librosa.load('s4_rohan2000.wav', sr=None)

# Define the filter coefficients
filter_order = 1000
filter_cutoff = 4000 # Hz
filter_coeffs = sps.firwin(filter_order, filter_cutoff, fs=fs)

# Apply the filter to the recorded signal
filtered_signal = sps.convolve(recorded_signal, filter_coeffs, mode='same')

# Plot the recorded and filtered signals
time = np.arange(len(recorded_signal)) / fs

fig, ax = plt.subplots(2, 1, sharex=True, figsize=(8, 6))
ax[0].plot(time, recorded_signal)
ax[0].set_ylabel('Amplitude')
ax[0].set_title('Recorded signal')
ax[1].plot(time, filtered_signal)
ax[1].set_xlabel('Time (s)')
ax[1].set_ylabel('Amplitude')
ax[1].set_title('Filtered signal')
plt.show()

#new new new i guess the correct one!
import numpy as np
from scipy.io import wavfile
import matplotlib.pyplot as plt
import scipy.signal as sps


import librosa

from pydub import AudioSegment
def DFT(x):
    """
    Function to calculate the 
    discrete Fourier Transform 
    of a 1D real-valued signal x
    """

    N = len(x)
    n = np.arange(N)
    k = n.reshape((N, 1))
    e = np.exp(-2j * np.pi * k * n / N)
    
    X = np.dot(e, x)
    
    return X

_, signal = wavfile.read('s3_rohan2000.wav')
# Define the sampling frequencies to analyze
fs = [2000]


# Calculate DFT and plot magnitude spectrum for each sampling frequency
for i in fs:
    # Resample the signal
    new_rate = i
    number_of_samples = round(len(signal) * float(new_rate) / _)
    resampled_signal = sps.resample(signal, number_of_samples)

    # Number of samples in the resampled signal
    N = resampled_signal.shape[0]

    # Time vector
    t = np.arange(N) / new_rate

    # Frequency vector
    freq_range = np.linspace(0, new_rate/2, N//2)
  
    # Calculate DFT
    dft_signal = DFT(resampled_signal)
    # Plot magnitude spectrum
    plt.figure()
    plt.plot(freq_range, np.abs(dft_signal[:N//2]))
    plt.xlabel('Frequency (Hz)')
    plt.ylabel('Magnitude')
    plt.title('Magnitude Spectrum (fs = {} Hz)'.format(new_rate))
    plt.show()

#filtering of the signals!
# Load the recorded signal from a file
recorded_signal, fs = librosa.load('s3_rohan2000.wav', sr=None)

# Define the filter coefficients
filter_order = 100
filter_cutoff = 180 # Hz
filter_coeffs = sps.firwin(filter_order, filter_cutoff, fs=fs)

# Apply the filter to the recorded signal
filtered_signal = sps.convolve(recorded_signal, filter_coeffs, mode='same')

# Plot the recorded and filtered signals
time = np.arange(len(recorded_signal)) / fs

fig, ax = plt.subplots(2, 1, sharex=True, figsize=(8, 6))
ax[0].plot(time, recorded_signal)
ax[0].set_ylabel('Amplitude')
ax[0].set_title('Recorded signal')
ax[1].plot(time, filtered_signal)
ax[1].set_xlabel('Time (s)')
ax[1].set_ylabel('Amplitude')
ax[1].set_title('Filtered signal')
plt.show()